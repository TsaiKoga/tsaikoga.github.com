
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>TsaiKoga Blog</title>
  <meta name="author" content="TsaiKoga">

  
  <meta name="description" content="首先，我要提一下管理的四大原则，因为它真是至理名言: 管理的四大原则 计划：设定目标，制定实现目标的战略，指定计划以整合和协调各项活动。
组织：决定需要做什么，怎么做，谁去做。
领导：指导和激励所有群体和个人去实现目标。
控制：达成目标与预订计划评估是否按照计划进行。 大学团队管理经历 &nbsp &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://TsaiKoga.github.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="TsaiKoga Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=Vollkorn:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Cabin' rel='stylesheet' type='text/css'>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42786505-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">TsaiKoga Blog</a></h1>
</hgroup>

</header>
<div class="navi">
<ul>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/aboutme/">Author</a></li>
</ul>
</div>

  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/04/tuan-dui-guan-li/">团队管理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-04T09:33:00+08:00" pubdate data-updated="true">Mar 4<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先，我要提一下管理的四大原则，因为它真是至理名言:</p>

<h5>管理的四大原则</h5>

<ol>
<li>计划：设定目标，制定实现目标的战略，指定计划以整合和协调各项活动。</li>
<li>组织：决定需要做什么，怎么做，谁去做。</li>
<li>领导：指导和激励所有群体和个人去实现目标。</li>
<li>控制：达成目标与预订计划评估是否按照计划进行。</li>
</ol>


<h5>大学团队管理经历</h5>

<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://tsaikoga.github.io/blog/2014/02/25/min-jie-kai-fa/">上一章</a>我们提到项目 ce 被分为三期，而我在第一期担任的是开发职务，第二期担任管理团队职务。
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一期时，当我们刚参与团队的第一次开发时，我们犯下许多错误：</p>

<blockquote><p><strong>任务划分问题：</strong>团队管理者犯了一个错误，他将三个联系紧密的页面分别安排给我和另一同学。这导致我很难开始自己的开发，因为只有需求文档和页面制作要求，通过询问得到另一同学流出的数据，我开始进行编码，但还是因为另一同学还没完成那个页面，之前对流出的数据也不能保证正确，所以当他出错时，我又得再次更改代码。这是这个任务拖慢的主要原因；当然还有一个原因，因为我和另一同学刚参与编码，有很多东西要学，必须边学习边工作，而任务是按照有经验人士的工作时间安排的，所以计划时间不合理。</p>

<p><strong>目标消失问题：</strong>在第一期后期大家都变成了一个打代码的机器人，直到全部任务都完成，团队准备集成测试时，才发现这些完成的流程不能很好地连接在一起。每个人只管完成自己的任务，却不知道一些模块组合起来后却没有什么用处。所以，团队的每个成员都必须明确自己的目标，知道自己负责的流程的作用。</p>

<p><strong>文档修改问题：</strong>在开发过程中，难免会发现一些数据库不合理的问题，如增加或减少一个字段；而我们只修改了数据库 mysql 的内容和数据库表的文档内容（有时还没改），对于数据库表间关系图中的内容没进行丝毫更改。这导致有人关注数据库表间关系而进行开发时，不知道数据库已经改变，致使开发速度减慢。</p></blockquote>

<p><strong>纠正方式：</strong></p>

<blockquote><p><strong>合理任务划分:</strong>通过流程划分各人任务，而不是通过难易程度;对于任务的难易程度结合个人能力划分任务的时间要求。</p>

<p><strong>确立模块目标:</strong>这里的目标是主目标和子目标，成员必须知道项目的主要目标是什么，还必须了解和实现自己的子目标。</p>

<p><strong>文档同步更新：</strong>所有关于项目更改的内容如果有对应的文档，应该将文档一起进行更改。如果是项目刚开始阶段，必须将项目中所有文档列出给所有成员，以便查找。</p></blockquote>

<hr />

<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第二期时，我们已经吸收了第一期的经验教训；并且通过第一期开发，我们所有人都有了几个月的开发经验，第二期不会像第一期那样拖了很久。这里讲一下管理者具体做的事情。</p>

<blockquote><p><strong>对具体的模块进行任务划分和人员安排,并使用软件进行管理：</strong>由于得到上一期的经验教训，我们将人员划分成两个人一组(其中一个人熟悉这个流程)，每一组负责一个流程。这样流程中的页面有两个人负责。每个页面一个任务。并且每个人的页面都是连贯的。用 redmine 登记任务的内容，开始时间，计划完成时间和实际完成时间以及负责的人员等等，完成任务必须及时更新。</p>

<p><strong>解释所需的流程、文档和封装库：</strong>团队成员开会对流程进行讲解，并将所有封装库的用法和作用列举出来，要求所有成员在编码时，尽量使用封装库。</p>

<p><strong>使用软件进行及时沟通,每周开大会:</strong>通过类似微博的团队管理软件每天在线汇报任务进度，对项目进度进行把控；设立周六大讨论，主要汇报讲解这周所遇到的问题并提出解决方案，并汇报流程总体进度。</p>

<p><strong>成员心理识别和调整：</strong>要及时发现成员的心理，并及时调整好，防止由于成员自己的问题而影响他人心理或直接导致项目拖慢。</p>

<p><strong>及时开会进行紧急处理：</strong>对较大的问题，应马上开会进行商量和处理，使全体成员都有权提出自己意见并了解。</p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/25/min-jie-kai-fa/">敏捷开发</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-25T13:23:00+08:00" pubdate data-updated="true">Feb 25<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/posts/2014-02-25/minjie.jpg" title="敏捷开发图" alt="图片无法显示" /></p>

<h5>敏捷开发的定义：</h5>

<p>是一种<strong>以人为核心、迭代、循环渐进的开发方法</strong>。在敏捷开发中项目被切分为多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。简而言之，就是把一个大项目切分成多个<strong>相互联系但可独立运行的子项目</strong>，并<strong>分别完成</strong>。在此过程软件一直处于可使用状态。</p>

<h5>敏捷开发 5 大价值观</h5>

<ol>
<li>沟通: 团队内部的开发人员之间沟通。</li>
<li>简单: 就是指简单的建模，如画一两张图表来代替几十甚至几百行的代码。</li>
<li>反馈: 过度自信是编程的职业病，反馈则是其处方。</li>
<li>勇气: 当你的决策证明是不合适的时候，你就需要做出重大的决策，放弃或重构你的工作，修正你的方向。</li>
<li>谦逊: 这个就不用我解释了。</li>
</ol>


<h5>敏捷开发核心做法</h5>

<ol>
<li>测试驱动开发</li>
<li>结对编程: 指<strong>两位程序员</strong>肩并肩地坐在同一台电脑前<strong>合作完成</strong>同一个设计、同一个算法、同一段代码或同一组测试。</li>
<li>持续集成:</li>
<li>每日站立会议</li>
<li>共同拥有代码</li>
<li>系统隐喻</li>
</ol>


<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了敏捷开发模式，目前所具有的开发模式还有好几种,如：瀑布模型，快速原型模型，增量模型，螺旋模型，喷泉模型。
 我在大学的实验室中使用 Rails 框架进行开发，使用的是敏捷开发模式。虽然如此，但是我们团队的敏捷开发还是带有其他模型的特征，可能因为我们还是学生团队，不是一个真正意义上的商业团队(我们平常还必须上课)。</p>

<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我先通过我们团队负责的一个项目（在这里我们叫它为ce）来阐述，我们为什么不是真正的敏捷，而是有有快速原型和增量的特征的敏捷，或者说我们是采用混合模式。</p>

<p><span style="text-align:center"><img src="/images/posts/2014-02-25/zengliang.jpg" title="增量模型图" alt="图片无法显示" /></span></p>

<ol>
<li><p>ce 首先通过实现前台大部分界面（没有功能）的<strong>样品给客户观看并给予讲解</strong>。客户可以清楚的看到有具体形态而无功能的样品，从而有助于客户提出有<strong>针对性的修改意见</strong>。而参与调研的师兄们对<strong>样品进行再次修改</strong>，并再次呈现给客户看，直到双方达成共识为止；之后师兄们就对这些调研后的资料进行讨论并据此形成<strong>规格说明文档</strong>（我们的规格说明文档是前台界面的图片，并用文字等方式对其功能进行阐述，当然还有一些流程图），然后把之前做的不具有功能的<strong>样品抛弃</strong>。很明显这是<strong>结合了快速原型模型</strong>，从而得到它的<strong>优点</strong>：规格说明文档<strong>正确的描述客户的需求</strong>，减少了设计和编码阶段发生的可能性错误。</p></li>
<li><p>当进入开发阶段时，团队要求将这个 ce 项目分成三期；每期有几条流程，而各个阶段的流程互不影响。并在第一期开发结束后部署给企业使用，这样企业就能拥有<strong>充裕的时间学习和适应</strong>此系统,减少一个新系统可能给客户组织带来的冲击。第二期进行开发直至完成后再部署给企业，这样企业已经事先使用过系统，对系统的排斥性不会那么强了。<strong>增量模型是将软件产品作为一系列的增量构件来设计，编码，集成和测试</strong>。而 ce 的这种开发方式明显和增量模型类似,当然，也可以说是<strong>敏捷开发的增量交付</strong>。</p></li>
<li><p>最后，我想要通过实验室的 ce 项目来说明敏捷开发的特征。</p></li>
</ol>


<p><strong>持续集成：</strong>一开始，我已经提到 ce 调研，那时候形成的规格说明文档有项目每个页面的设计方式，这样 ce 的每个模块以及每个页面都已经划分好，剩下的就是开发人员对每个页面的实现。实现一个页面后进行白盒测试，一个模块的所有页面完成时进行集成测试，这符合敏捷开发的方式。</p>

<p><strong>测试驱动开发：</strong>很可惜，团队的成员（包括老成员）没有 <strong>TDD (测试驱动开发)</strong> 的经验，我们使用一个星期的时间学习，最后在讨论中决定不使用 TDD，主要原因是 TDD 讲究先写测试后开发，而我们已经进入了开发阶段；再加上没有经验，如果使用TDD很大可能会拖慢项目进度。</p>

<p><strong>每日站立会议：</strong>我们每天都会在实验室进行工作，并且在每天晚上进行一个名叫<strong>三分钟站立会议</strong>的谈论，这个会议是就是要求每个人用三分钟左右的时间回报当天的工作内容、任务目标及所遇到的问题；我们希望从这次会议<strong>获得团队中每个人的任务进度和状态，从而有效的对进度进行把控</strong>。这就符合敏捷开发的五大价值观的其中两个：<strong>沟通</strong>和<strong>反馈</strong>。</p>

<p>我清楚的记得我当初被任命开发一个叫做“生产通知单”的页面，这个页面设计上不合理，集结了很多表，关系复杂，数据量大，并且由于 Extjs 特性，导致页面加载速度慢。后来团队选择废除这个页面，上千行的代码就这样被废除了。这也符合敏捷开发的一大价值观：<strong>勇气</strong>。</p>

<p><strong>系统拥有共同的代码：</strong>我们使用 Git 对 ce 的代码进行版本管理，由于 Git 巧妙的设计，团队<strong>每个成员都用有 ce 的代码</strong>（可能是各自不同的版本），不会因为仓库的代码错误和丢失而导致项目失败。</p>

<p><strong>代码的评审和重构：</strong>由于进入第一期末尾时，发现有很多 bug ，最终讨论设立一个代码评审人员(一个师兄，他的经验比我们丰富)，他负责对代码进行评审，并将需要重构的代码标记出来形成一个新的任务，将任务授予相应的开发人员。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/07/linuxyong-hu-he-quan-xian/">Linux用户和权限</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-07T16:14:00+08:00" pubdate data-updated="true">Nov 7<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Linux是一个多用户，多任务操作系统。这意味多个用户可以同时使用一个操作系统。虽然便利，但也带来了许多潜在的威胁。
为了解决这些安全性问题,Linux为用户设置了权限。</p>

<h2>用户</h2>

<p>Linxu系统规定了4中不类型的用户：
 1. 超级用户(root)
 2. 文件主(owner)
 3. 同组用户(group)
 4. 可以访问系统的其他用户(others)</p>

<p>用户具有3种不同的存取权限：
 1. 读&reg;;             二进制：100; 十进制：4
 2. 写(w);             二进制：010; 十进制：2
 3. 可执行或查询(x);   二进制：001; 十进制：1</p>

<hr />

<p>他们从左到右排列代表一个用户对文件或目录的存取权限。</p>

<p>可以使用 ls -d 查看目录文件的使用权限。如以下信息：（这些信息都包含在I节点，可以通过 ls -i/&mdash;inode 查看）</p>

<pre><code>-rwxr-xr--  2  tsaikoga  group  198  Sep  8  14:06  ..
</code></pre>

<ol>
<li>第一个字段中第一个字符标识文件类型，有如下几种表示：</li>
<li>- 普通文件。</li>
<li>d 目录。</li>
<li>b 块设备。</li>
<li>c 字符设备。</li>
<li><p>l 符号链接文件。</p></li>
<li><p>随后9个字符是用户的存取权限:</p></li>
<li>前三个rwx代表可读，可写，可执行。十进制：7；</li>
<li>接着三个代表十进制: 5；</li>
<li>最后十进制为：4；</li>
<li>当为-时，代表没有权限；</li>
<li>当为 s 时，代表文件执行时，把该文件UID或GID赋予执行进程的UID（用户ID）或GID（组ID）；</li>
<li><p>当为 t 时，设置了粘着标志位（留在内存，不被换出）。如果该文件是目录，则在改目录的文件只能被root或文件主删除。如果是可执行文件，该文件执行后，指向其正文段的指针仍留在内存;这样再次执行时，系统能更快地装入文件。</p></li>
<li><p>表示文件链接数</p></li>
<li><p>文件主</p></li>
<li><p>文件所属的组</p></li>
<li><p>文件容量</p></li>
<li><p>修改日期</p></li>
<li><p>文件名</p></li>
</ol>


<hr />

<h2>改变文件权限</h2>

<p>可以通过两个命令改变文件权限：</p>

<ul>
<li><p>chmod
用于改变或设置文件或目录的存取权限。</p></li>
<li><p>chown
用于改变某个文件或目录的所有者或所属组。</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/06/xiang-mu-dai-ma-shi-xian/">项目代码实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-06T13:14:00+08:00" pubdate data-updated="true">Nov 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转眼间已经到了大四，想想大三和暑假在做的项目，自己在其中参与开发也曾参与管理；提到开发，从一开始对语言和业务都很陌生，任务不能按时完成；到后来逐渐掌握方法，准时完成任务。这个期间是一个逐渐迷失，然后发现问题，之后解决问题的过程。所以，在这里总结一下自己的经验和体会。</p>

<p>在讲述之前先说一下背景:</p>

<h4>背景：</h4>

<blockquote><p>首先，说一下我们所使用的语言和框架：</p>

<ul>
<li>前台：主要是Extjs</li>
<li>后台：Ruby</li>
<li>框架：Rails</li>
</ul>


<p>其次，说明一下我们所做的系统内容和功能：</p>

<ul>
<li>它是一个有关服装的一套生产流程的管理系统，包括板房打板，制作订单和制单，库存管理，采购管理，员工工资预算等内容。</li>
<li>页面所涉及的组件一般为panel（面板），form（表单），grid（表格），tree（树）和window（窗口）。</li>
<li>页面功能一般为对记录进行增删查改，对单据进行打印和导出Excel的功能。</li>
</ul>


<p>最后，讲述以下我们所做的系统复杂性：</p>

<ul>
<li>其实，由前面的内容和功能看好像不复杂，大部分系统都是这样。但是，看似简单的功能，实现并不容易；因为公司涉及流程范围广，系统较大，而系统所需的表有100多张；经常一个页面涉及10多张表，所以查找关联时比较吃力。</li>
</ul>
</blockquote>

<hr />

<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我开始接触此项目时，团队已经调研完并且设计好了数据库；而我们对数据库和业务都不熟悉；一开始就进入实现阶段常常会产生一个接连一个的问题；面对这些问题，我们探寻一条解决道路，团队开始采取的方法是：</p>

<p>1.业务完全不了解：</p>

<ul>
<li>先<strong>查看</strong>之前调研出来的<strong>流程图</strong>;</li>
<li>要求之前调研的人员对<strong>大体的流程</strong>进行<strong>讲解</strong>（因为流程图这种文档不一定能被第三方所理解，所以必须进行讲解；但是一开始讲解太全不易接受，所以我提议一开始讲大体内容，实现前针对模块的流程进行讲解）;</li>
<li>开发时对所做的<strong>模块流程</strong>进行<strong>讲解</strong>;</li>
</ul>


<p>2.数据库设计问题：</p>

<ul>
<li>对于这个问题，要看问题的大小，组织当时<strong>数据库设计相关人员进行讨论</strong>;</li>
<li>如果易于修改，不会改动太大，不会造成较大影响的，可以进行修改。</li>
<li>若影响较大，寻求其他途径代替，而不改动数据库。</li>
</ul>


<hr />

<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好，现在来讲我的代码实现方法，因为还是学生，不是什么正规公司，在代码设计上不像大公司那样规范；为了完成每一个任务，自己逐渐掌握的一套方法：</p>

<h4>准备:</h4>

<p>1.了解所要做的<strong>线路的流程</strong>，究竟是要干什么：
 理解所要实现的功能，所做的页面比起原来公司方式多了什么好处或修复了什么弊端。这样有助于理解并且找出系统设计的错误，及早改正。</p>

<p>2.查看<strong>数据库</strong>的设计的<strong>有关联的表</strong>：</p>

<ul>
<li>首先可以先看名字，你之后设计的函数或变量名字其实很多可以从数据库的表名或字段名借鉴。</li>
<li>将你前台所需要的字段找出来，你的页面将通过哪张表开始显示这个字段，找出一条搜索路径。（这里是一些大致需要查找的地方，如表单，表格）</li>
</ul>


<p>3.简要<strong>设计函数和分割代码</strong>(这里不是很细致地设计，而只是提出设计，实现是可以按着这个方向编写代码)：</p>

<ul>
<li>根据功能设计前台函数名（这也只能从较高层次上设计，如果熟练了，就知道页面大概要什么函数了，到那时设计起来简单）。</li>
<li>计高内聚低耦合的代码（这个比较难，一开始会因为站在比较高的地方，对一些细致的内容不了解或是业务知识不清晰而做出设计，最后由于一些功能不一致而修改，发现内聚性较差）。</li>
</ul>


<p>4.根据前台功能开始着手<strong>设计后台</strong>，前台所需发的请求，归纳后台需要什么内容，将后台处理过程划分，设计后台方法名。</p>

<h4>实现:</h4>

<p>5.开始着手敲代码实现，在前台这个期间我经历了三个阶段：</p>

<ul>
<li><p>没显示内容：怎么办？只好不停的调试；因为使用js的ext库做前台，所以我会在代码中用console.log()通过chrome的审查元素进行调试。</p>

<p><strong>结论：</strong>第一次还是不要一次性写太多内容；对于前台，你只需要写出那么一个总体显示框架就行了（如：一个布局：上面有个form，下面有个grid，显示出来就行了），之后再逐步细化。</p></li>
<li><p>当前台显示出来后，我认为根据MVC，View要发送请求，必须通过前台的功能实现，所以着手写之前所设计的前台功能代码：增删查改的ajax。但是，这样编代码后思想会很乱，容易分心，效率低下。</p>

<p><strong>结论：</strong>先做号前台页面的显示和最基本的数据显示（包括后台代码）；然后还是前台的一个功能设计出来后，后台根据这个请求实现，完成后台代码后测试这个功能是否可用。</p></li>
<li><p>最后一阶段就是一个一个的功能实现了，接在在一起时出现了问题，这时也只能调试。</p>

<p><strong>结论：</strong>调试时先判断是前台还是后台，这一期间一般发生在后台；如果可以通过提示的错误判断，则判断哪个范围出错，并那个范围进行调试；不然就顺着请求的访问路径测试，逐步调试。</p></li>
</ul>


<h4>总结:</h4>

<blockquote><p>编代码时</p>

<p>1.先整体后局部：做前台先将整体框架显示，再一个一个进行实现，而功能先不做；</p>

<p>2.先简单后复杂（复杂局部实现）：找出前台要显示的基本信息，编写后台实现基本的显示信息，再用一个功能一个功能实现;</p>

<p>3.先局部后整体：在此期间的不断地测试。</p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/26/rails-assets-pipeline/">Rails Assets Pipeline</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-26T10:10:00+08:00" pubdate data-updated="true">Oct 26<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本章我将从三个方面介绍Assets Pipeline:</p>

<ol>
<li>Assets Pipeline的产生背景</li>
<li>Assets Pipeline的定义</li>
<li>Assets Pipeline的主要功能</li>
<li>Assets Pipeline的使用方法</li>
<li>生产环境下的Assets Pipeline</li>
</ol>


<hr />

<h3>背景：</h3>

<p>在Rails项目中，只用<strong>public/文件夹是公开读取</strong>的，所以我们通常会把<strong>javascript,css等静态资源放入</strong>其中，好让浏览器直接读取。但是随着这些静态文件越来越多，如何管理他们成为一个问题，为了加快浏览器下载速度，我们要合并javascript和stylesheet文件，来减少浏览器请求次数，更进一步还会压缩文件来加速下载时间。</p>

<p>  后来,Rails3引进了Assets Pipeline的新功能，它可以让静态资源存放在不同目录下，rails帮你组合压缩，特别是一些javascript插件。没有Assets Pipeline之前，我们必须将javascript复制到public/中浏览器才可以读取。</p>

<blockquote><p>Yahoo!和google都有自己开源的压缩工具<a href="http://yui.github.io/yuicompressor/">YUI Compressor</a>和<a href="https://developers.google.com/closure/compiler">Closure Compile</a>。</p></blockquote>

<hr />

<h3>什么是Assets Pipeline：</h3>

<p>Assets Pipeline是能<strong>使Javascript,CSS的assets（包括自己在assets文件夹中写的erb,sass和coffescript文件）连接、缩小和压缩的一个框架</strong>。这个框架通过它的<strong>中心库Sprokets(将资源预处理，压缩和缩小)</strong>使所有rails开发者从中受益。</p>

<p>assets pipeline是默认启动的，如果想关闭也可以到config/application.rb文件中将如下代码放入：</p>

<pre><code>    config.assets.enable = false
</code></pre>

<p>当然，我们也可以在创建项目时，就不产生assets:</p>

<pre><code>    rails new appname --skip-sprockets
</code></pre>

<hr />

<h3>主要功能:</h3>

<ul>
<li><p><strong>连接：(减少浏览器请求数)</strong></p>

<p>  它可以避免浏览器为了渲染页面而不得不发送过多的请求。网页浏览器限制了并行请求的数量， 所以更少的请求能让你的应用程序加载更快。</p>

<p>  Rails 默认将所有的 JavaScript 文件连结成一个主要的 .js 文件，和将所有的 CSS 文件连结成一个主要的 .css 文件。在生产环境中， Rails 给<strong>每个文件名插入一个 MD5 指纹</strong>,以便<strong>文件被网页浏览器缓存</strong>。你可以通过修改指纹使缓存无效，这在你修改文件后会自动发生。</p></li>
<li><p><strong>缩小/压缩：(加快js,css及图片等静态资源下载速度)</strong></p>

<p>  对于 CSS 文件，是通过去除空格和注释来实现的。</p>

<p>  对于 JavsScript, 会有更多的复杂过程。你可以从选项中选择一套构件或者指定你自己的。</p></li>
<li><p><strong>使用索引文件：(建立索引文件提高访问速度)</strong></p>

<p>  Sprockets 对一些特殊的用途会使用名为 index (使用相关扩展) 的文件，作为一系列相关文件的索引。</p></li>
<li><p><strong>高级语言预编译(coffeescript &ndash;> javascript / scss &ndash;> css等)：</strong></p>

<p>  它能你使用更高级的语言来编写资源，然后预编译成实质的资源。默认支持的语言包括 CSS 的 Sass，JavaScript 的 CoffeeScript 和可用于所有资源的 ERB.</p></li>
</ul>


<hr />

<h3>使用方法：</h3>

<p>在 Rails 之前的版本里，所有的资源都放置在 public 的子目录下比如 images, javascript 和 stylesheets. 对于 asset pipeline, 这些资源现在被指定到 <strong>app/assets 目录</strong>。这个<strong>目录下的所有文件都通过 Sprockets 中间件供应</strong>，这个中间件通过引入 sprockets gem 使用。</p>

<h4>资源组织：</h4>

<p>Pipeline assets 可以被放置到一个应用程序中这三个位置中的一个:</p>

<ul>
<li>app/assets 放置属于<strong>应用程序的资源</strong>，比如自选图像，JavaScript 文件和样式文件。</li>
<li>lib/assets 用于不在应用程序<strong>范围内的自有函式库</strong>，或者那些<strong>跨应用程序共通的函式</strong>。</li>
<li>vendor/assets 用于属于<strong>外部实体的资源</strong>，比如 JavaScript 插件和 CSS 框架的代码。</li>
</ul>


<hr />

<ol type="a">
<li><p>搜索路径：</p>

<p>介绍搜索路径时，先来介绍<strong>资源清单</strong>：</p>

<blockquote><ul>
<li><p>资源清单一般是app/assets/stylesheets/application.css和app/assets/javascripts/application.js</p></li>
<li><p>assets pipeline<strong>默认搜索路径将会在app/assets/images和三个资源路径app/assets/、lib/assets/、 vendor/assets下的所有javascripts, stylesheets子目录</strong>，而索引的<strong>文件将由文件清单给出</strong>,如：//= require home 将是 app/assets/javascripts/home.js。</p></li>
<li><p>下图就是一份JS资源清单：</p></li>
</ul>
</blockquote>

<p><img src="/images/posts/2013-10-26/resource_list.png" title="JS资源清单" alt="无法显示图片" /></p>

<p>刚才已经提到，那是默认的搜索路径，你也可以附加路径：在config/application.rb里添加路径到pipeline。例如：</p>

<pre><code>config.assets.paths &lt;&lt; Rails.root.join("app", "assets", "flash")
</code></pre>

<p><em>注意：想在<strong>资源清单外引用</strong>的文件必须加载到<strong>预编译列表</strong>里，否则它们在<strong>生产环境</strong>将不可以用。</em></p></li>
<li><p>使用索引文件:</p>

<p>如果你了解数据库，就应该对索引很熟悉。如果一个字段<strong>经常被查找</strong>，你可以将它<strong>建立索引</strong>从而提高访问速度。</p>

<p>Sprockets也采取类似方法，对一些<strong>特殊的用途</strong>会使用名为 index (使用相关扩展) 的文件。</p>

<blockquote><p>例如，如果你的<strong>许多模块都要使用某个 jQuery 函式库</strong>，这个函式库存放在 lib/assets/library_name。 lib/assets/library_name/index.js 会作为<strong>这个库的所有文件的 manifest</strong>. 这个文件可以按顺序包含一组需要使用的文件，或者一个简单的 require_tree 指令。</p></blockquote></li>
<li><p>连接资源代码：</p>

<p><strong>使用标签：</strong></p>

<p>pipeline(在当前的环境上下文中没有被关闭)提供标签访问你的资源,这些文件通过Sprockets获得。</p>

<p>Sprockets 也会搜寻在 config.assets.paths 指定的所有路径，这些路径包括常规的应用程序路径和任何被 Rails engines 添加进来的路径。</p>

<pre><code>&lt;%= stylesheet_link_tag "application" %&gt;
&lt;%= javascript_include_tag "application" %&gt;
&lt;%= image_tag "rails.png" %&gt;
</code></pre>

<p><strong>CSS:</strong></p>

<p>assets pipeline会<strong>自动解析erb</strong>，你可以在CSS增加扩展名.erb，这样资源中就可以<strong>使用helpers</strong>方法(如：asset_path)。</p>

<p>使用assets pipeline，<strong>资源路径必须重写</strong>并且sass-rails提供两个helpers方法：-url和-path。</p>

<p><strong>JS:</strong></p>

<p>使用erb扩展名可以使用asset_path的helpers方法。你也可以在coffeescript增加扩展名erb。</p></li>
<li><p>资源清单和指令：</p>

<p><strong>作用：</strong>Sprockets 使用资源清单文件去<strong>确认哪些资源要引入并供应</strong>的。</p>

<p>这些资源清单文件包含一些 <strong>指令</strong> — 告诉 Sprockets 哪些文件要被<strong>按顺序引入</strong>，然后将它们<strong>连结成单个 CSS 或者 JavaScript 文件的指示</strong>。根据这些指令， Sprockets 加载这些被指定的文件，如果有必要就对它们<strong>进行加工</strong>，接着将它们<strong>连结成单个文件然后压缩</strong>它们 ( 如果 <strong>Rails.application.config.assets.compress</strong> 为 true ).</p>

<p>由于只处理单个文件而不是多个， 浏览器可以发起更少的请求所以页面的加载时间将会大大的缩减。</p>

<p>还记得清单内容吗？之前提到的资源清单。</p>

<p><strong>构成：</strong></p>

<ul>
<li>JS资源清单:</li>
</ul>


<p>那些<strong>以//=开头的注释就是指令</strong>，而 <strong>require 指令</strong>是用于告诉 Sprockets <strong>需要加入</strong>的文件,也不用加扩展名，当资源清单是js文件，Sprockets会假设你加入的是一个.js文件。</p>

<p>  <strong>require_tree</strong> 指令告诉 Sprockets <strong>递归</strong>地去包含在<strong>指定目录下<em>所有</em></strong> 的 JavaScript 文件到<strong>输出里</strong>。 这些<strong>路径必须在资源清单文件中有相关的指定</strong>。 有也可以使用 require_directory 指令，它会将在某个特定目录下所有的 JavaScript 文件包含进去，但不递归。</p>

<pre><code>//= require jquery
//= require jquery_ujs
//= require_tree .
</code></pre>

<ul>
<li>CSS资源清单：</li>
</ul>


<p>  用css的注释开头，同样用require引入文件，指令<strong>require_tree</strong>和JS中的一样（<strong>加入当前目录所有stylesheets文件</strong>），require_self将文件中的 CSS (如果有) 放置到 require_self 调用的准确位置。</p>

<pre><code>/* ...
*= require_self
*= require_tree .
*/
</code></pre>

<p><em>注意：用到多个sass文件时，用<strong>@import rule</strong>替代Sprockets</em>指令，Sprockets 指令在 Sass 文件中定义的<strong>变量和 mixins</strong> 都只能在其<strong>被定义的文档</strong>中可用。_</p></li>
<li><p>预处理：</p>

<p>文件的<strong>扩展名</strong>被用于判断某个资源文件要进入<strong>哪个预处理过程</strong>。</p>

<p><strong>预处理</strong>可以通过<strong>添加其它的扩展</strong>被加入，扩展的<strong>处理顺序</strong>按是<strong>从右到左</strong>。这应该用于需要按顺序处理的过程。编译好的 JavaScript 和 CSS 文件送回给浏览。</p>

<blockquote><p>例如：</p>

<p>app/assets/javascripts/projects.js.erb.coffee，那么现由 CoffeeScript 拦截器先处理。它不能解析 ERB 所以你会碰到问题。</p></blockquote></li>
</ol>


<hr />

<h4>生产环境：</h4>

<ul>
<li><p>预编译资源</p>

<p>Rails 本身绑定了一个 <strong>rake</strong> 任何去编译资源资源清单和 pipeline 中的其它文件到<strong>磁盘</strong>里。</p>

<p><strong>编译后的资源</strong>都被写入到了在 config.assets.prefix 指定的位置里。默认情况下，是 <strong>pulibc/assets 目录</strong>。</p>

<p>为了更<strong>快速的预编译资源</strong>，你可以在 config/application.rb 里将 <strong>config.assets.initialize_on_precompile 设置为 false</strong> 去<strong>部分加载</strong>你的应用程序。</p>

<blockquote><p>如果你设置 config.assets.initialize_on_precomile 为 false,在<strong>开发模式</strong>范围内会<strong>忽略这个标记的值</strong>. 改变这个标记也会影响到 engines. Engines 也可以<strong>指定预编译资源.</strong> 因为完整的环境还没有加载完, <strong>engines (或者其他的 gems) 将不会被加载</strong>, 这会引起<strong>资源丢失</strong>.</p></blockquote>

<p>所以，你可以通过以下命令生成已编译版本的资源文件:</p>

<pre><code>bundle exec rake assets:precompile
</code></pre></li>
</ul>


<hr />
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/25/jia-zai-rails/">加载Rails</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-25T22:58:00+08:00" pubdate data-updated="true">Oct 25<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在上一篇文章<a href="http://tsaikoga.github.io/blog/2013/10/24/railschu-shi-hua-he-qi-dong-guo-cheng/">Rails服务启动过程</a>,最后加载的config/application.rb文件中显示：</p>

<pre><code>    require 'rails/all'
</code></pre>

<p>这个文件在railties/lib/rails/all.rb。</p>

<hr />

<h3>railties/lib/rails/all.rb</h3>

<p>这个文件非常重要，它加载了rails的所有个体框架，从中可以知道这些<strong>框架的加载顺序</strong>：</p>

<pre><code>require "rails"

    %{
        active_record
        action_controller
        action_mail
        rails/test_unit
        sprockets
    }.each do |framework|
        begin
            require "#{framework}/railtie"          # 文件active_record/railtie等
      rescue LoadError
        end
    end
</code></pre>

<blockquote><p><strong>railtie 是Rails的核心框架</strong>，并且提供hooks来修改启动时的载入流程，
如果需要在启动过程或之后与rails框架进行交互，就需要加载Railtie。</p></blockquote>

<hr />

<h3>config/environment.rb</h3>

<p>当config/application.rb已经将rails加载完成,并且<strong>定义了应用的命名空间</strong>（在一个module中mixin一个Application类）。</p>

<p>而在config/environment.rb文件中，你的<strong>项目被初始化</strong>，如：<strong>Examples::Application.initialize!(在application.rb中已经定义了)</strong>。</p>

<p>想知道初始化做了写什么吗？</p>

<hr />

<h3>railties/lib/rails/application.rb</h3>

<p>以下为初始化代码：(你的Application类继承Rails::Application类，而这个类就在railties/lib/rails/application.rb文件中)</p>

<pre><code>    def initialize!(group=:default) #:nodoc:
        raise "Application has been already initialized." if @initialized
        run_initializers(group, self)
        @initialized = true
        self
    end
</code></pre>

<p>Rails会贯穿这整个Rails::Application祖先类，重新排序和运行他们。</p>

<h3>Rack: lib/rack/server.rb</h3>

<p>在<a href="http://tsaikoga.github.io/blog/2013/10/24/railschu-shi-hua-he-qi-dong-guo-cheng/">上一篇</a>时,有提到Rack::Server类，它里面有一个app方法是这么定义的：</p>

<pre><code>    def app
        @app ||= begin
            if !::File.exist? options[:config]
                abort "configuration #{options[:config]} not found"
            end

            app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
            self.options.merge! options
            app
        end
    end
</code></pre>

<p>这里所指的app就是Rails的app（一种中间件），Rack将会调用所有提供的中间件。</p>

<pre><code>    def build_app(app)
        middleware[options[:environment]].reverse_each do |middleware|
            middleware = middleware.call(self) if middleware.respond_to?(:call)
            next unless middleware
            klass = middleware.shift
            app = klass.new(app, *middleware)
        end
        app
    end
</code></pre>

<p>以上代码build_app是被Server#start方法调用的，通过这个代码调用：</p>

<pre><code>    server.run wrapped_app, options, &amp;blk
</code></pre>

<p>所以，server.run将会依赖于你所使用的server程序(以上代码有传入一个程序块&amp;blk,他将关系到你运行的服务),
像是如果你是用的是Mongrel数据库，将会通过传入如下程序块运行：</p>

<pre><code>    def self.run(app, options={})
        server = ::Mongrel::HttpServer.new(
            options[:Host]           || '0.0.0.0',
            options[:Port]           || 8080,
            options[:num_processors] || 950,
            options[:throttle]       || 0,
            options[:timeout]        || 60)
        # Acts like Rack::URLMap, utilizing Mongrel's own path finding methods.
        # Use is similar to #run, replacing the app argument with a hash of
        # { path=&gt;app, ... } or an instance of Rack::URLMap.
        if options[:map]
            if app.is_a? Hash
                app.each do |path, appl|
                    path = '/'+path unless path[0] == ?/
                    server.register(path, Rack::Handler::Mongrel.new(appl))
                end
            elsif app.is_a? URLMap
                app.instance_variable_get(:@mapping).each do |(host, path, appl)|
                 next if !host.nil? &amp;&amp; !options[:Host].nil? &amp;&amp; options[:Host] != host
                 path = '/'+path unless path[0] == ?/
                 server.register(path, Rack::Handler::Mongrel.new(appl))
                end
            else
                raise ArgumentError, "first argument should be a Hash or URLMap"
            end
        else
            server.register('/', Rack::Handler::Mongrel.new(app))
        end
        yield server  if block_given?
        server.run.join
    end
</code></pre>

<p>以上代码使用Mongrel::HttpServer定义了server实例，然后使用server.run运行.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/24/railschu-shi-hua-he-qi-dong-guo-cheng/">Rails服务启动过程</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-24T14:51:00+08:00" pubdate data-updated="true">Oct 24<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我们都知道，每当我们console中输入rails s时，系统就启动了你的rails应用程序。</p>

<hr />

<h3>app程序中的bin/rails脚本</h3>

<p>它是由你的app程序的<strong>bin/rails脚本</strong>执行的(我们的rails命令在通过bin/rails脚本引用rails/commands.rb文件中)。</p>

<p><em>如：example_</em>app/bin/rails_</p>

<pre><code>    #!/usr/bin/env ruby
    APP_PATH = File.expand_path('../../config/application',  __FILE__)
    require_relative '../config/boot'
    require 'rails/commands'
</code></pre>

<p>APP_PATH常量将会在rails/commands中用到，而config/boot指向<strong>config/boot.rb</strong>文件，这个文件<strong>会加载和设置Bundler</strong>。</p>

<hr />

<h3>config/boot.rb加载gem</h3>

<p>前面bin/rails引入两个文件,现在我们先说第一个文件
config/boot.rb:</p>

<pre><code>    # Set up gems listed in the Gemfile.
    ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)

    require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])
</code></pre>

<p>config/boot.rb用ENV[&lsquo;BUNDLE_GEMFILE&rsquo;]定位Gemfile文件，当Gemfile文件存在时，就将它引入。这样一来，gem就被引入了。</p>

<hr />

<h3>rails/commands.rb执行rails命令</h3>

<p>前面config/boot.rb引入的第二个文件,但这个文件必须在第一个文件config/boot.rb文件引入后才被引入。
rails/commands.rb:</p>

<pre><code>    ARGV &lt;&lt; '--help' if ARGV.empty?

    aliases = {
        "g"  =&gt; "generate",
        "d"  =&gt; "destroy",
        "c"  =&gt; "console",
        "s"  =&gt; "server",
        "db" =&gt; "dbconsole",
        "r"  =&gt; "runner"
    }

    command = ARGV.shift
    command = aliases[command] || command
</code></pre>

<p>当你输入的是rails server的话，将会执行下列代码匹配你的命令：</p>

<pre><code>    when 'server'
        # Change to the application's path if there is no config.ru file in current dir.
        # This allows us to run `rails server` from other directories, but still get
        # the main config.ru and properly set the tmp directory.
        Dir.chdir(File.expand_path('../../', APP_PATH)) unless File.exists?(File.expand_path("config.ru"))

        require 'rails/commands/server'
        Rails::Server.new.tap do |server|
            # We need to require application after the server sets environment,
            # otherwise the --environment option given to the server won't propagate.
            require APP_PATH
            Dir.chdir(Rails.application.root)
            server.start
        end
</code></pre>

<p>刚才我们的bin/rails脚本中已经定义了常量APP_PATH为&#8221;config/application.rb&#8221;,而</p>

<pre><code>    Dir.chdir(File.expand\_path('../../', APP\_PATH)) unless File.exists?(File.expand\_path("config.ru"))
</code></pre>

<p>表示如果<strong>没有config.ru文件时，就加载rails/commands/server文件，否则加载config/application.rb</strong>。</p>

<p>也就是，你<strong>启动了服务前才帮你加载程序的应用文件application.rb</strong>。
application.rb这个文件将会加载Rails。</p>

<hr />

<h3>rails/commands/server.rb</h3>

<p>来看一下rails/commands/server中定义的类Rails::Server吧。</p>

<pre><code>    require 'fileutils'
    require 'optparse'
    require 'action_dispatch'

    module Rails
        class Server &lt; ::Rack::Server
</code></pre>

<p>这里引入的<strong>fileutils和optparse</strong>是<strong>标准的ruby库</strong>，分别提供文件的辅助方法和转化选择。</p>

<p>Rails::Server继承了Rack::Server,当<strong>Rack::Server被初始化(设置环境)</strong>时，Rack::Server也被初始化。</p>

<pre><code>    def initialize(*)
        super
        set_environment
    end
</code></pre>

<hr />

<p>Rack::Server是为<strong>以Rack为基础的应用提供公用的服务接口</strong>，rails就是其中之一。</p>

<ul>
<li><p>初始化设置环境：</p>

<p>  刚才提到的初始化代码如下：</p>

<pre><code>  def set_environment
      ENV["RAILS_ENV"] ||= options[:environment]
  end
</code></pre>

<p>  不要以为set_environment很少，options干了很多事情：</p>

<pre><code>  def options
      @options ||= parse_options(ARGV)
  end
</code></pre>

<p>  parse_options定义如下：</p>

<pre><code>  def parse_options(args)
      options = default_options

      # Don't evaluate CGI ISINDEX parameters.
      # http://hoohoo.ncsa.uiuc.edu/cgi/cl.html
      args.clear if ENV.include?("REQUEST_METHOD")

      options.merge! opt_parser.parse! args
      options[:config] = ::File.expand_path(options[:config])
      ENV["RACK_ENV"] = options[:environment]
      options
  end
</code></pre>

<p>  我们将一行一行解释，</p>

<p>  (1)选择default_options如下设置：</p>

<pre><code>  def default_options
      {
          :environment =&gt; ENV['RACK_ENV'] || "development",
          :pid         =&gt; nil,
          :Port        =&gt; 9292,
          :Host        =&gt; "0.0.0.0",
          :AccessLog   =&gt; [],
          :config      =&gt; "config.ru"
      }
  end
</code></pre>

<p>  它<strong>(Rack::Server)提供了默认环境和端口号等信息</strong>，还记得当rails/commands.rb中，如果存在config.ru时，就加载config/applicaton.rb文件吗？</p>

<p>  (2)当ENV哈希环境中没有REQUEST_METHOD这个键时，跳过而去执行合并选项。</p>

<p>  Rack::Server中的opt_server</p>

<pre><code>  def opt_parser
      Options.new
  end
</code></pre>

<p>  (3)Rails::Server重写parse!</p>

<pre><code>  def parse!(args)
      args, options = args.dup, {}

      opt_parser = OptionParser.new do |opts|
          opts.banner = "Usage: rails server [mongrel, thin, etc] [options]"
          opts.on("-p", "--port=port", Integer,
                          "Runs Rails on the specified port.", "Default: 3000") { |v| options[:Port] = v }
      ...
</code></pre></li>
</ul>


<p>刚才说default_options已经有了config.ru，这是回到之前rails.commands.rb文件，它加载了config/application.rb文件</p>

<hr />

<h3>config/application.rb</h3>

<p>当require APP_PATH被执行，<strong>config/applicaton.rb被加载，server.start就被调用</strong>了。
方法如下：</p>

<pre><code>    def start
        url = "#{options[:SSLEnable] ? 'https' : 'http'}://#{options[:Host]}:#{options[:Port]}"
        puts "=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}"
        puts "=&gt; Rails #{Rails.version} application starting in #{Rails.env} on #{url}"
        puts "=&gt; Run `rails server -h` for more startup options"
        trap(:INT) { exit }
        puts "=&gt; Ctrl-C to shutdown server" unless options[:daemonize]

        #Create required tmp directories if not found
        %w(cache pids sessions sockets).each do |dir_to_make|
            FileUtils.mkdir_p(Rails.root.join('tmp', dir_to_make))
        end

        unless options[:daemonize]
            wrapped_app # touch the app so the logger is set up

            console = ActiveSupport::Logger.new($stdout)
            console.formatter = Rails.logger.formatter

            Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
        end

        super
    ensure
        # The '-h' option calls exit before @options is set.
        # If we call 'options' with it unset, we get double help banners.
        puts 'Exiting' unless @options &amp;&amp; options[:daemonize]
    end
</code></pre>

<blockquote><ul>
<li><p>这个方法非常重要，我们可以看到前面有一堆提示，而后面<strong>创建了tmp/cache,tmp/pids,tmp/sessions和tmp/sockets文件夹</strong>,</p></li>
<li><p>在调用<strong>wrapped_app方法创建Rack应用</strong>。</p></li>
<li><p>并且<strong>定了ActiveSupport::Logger</strong>。</p></li>
</ul>
</blockquote>

<p>还记得<strong>options[:config]默认指向config.ru</strong>吗？这个文件中包含了：</p>

<pre><code>    # This file is used by Rack-based servers to start the application.

    require ::File.expand_path('../config/environment',  __FILE__)
    run &lt;%= app_const %&gt;
</code></pre>

<p>它<strong>引进了config/environment.rb</strong>文件，而<strong>environment.rb这个文件引入了config/application.rb</strong>文件</p>

<hr />

<h3>actionpack/lib/action_dispatch.rb</h3>

<p>Action Dispatch是rails框架的一个路由组件，提供routing,session和middlewares</p>

<p>也就是，你启动了服务前才帮你加载程序的应用文件application.rb。</p>

<hr />

<h4>总结：(自己所画的rails初始化过程图片)</h4>

<p><img src="/images/posts/2013-10-23/rails_initialize.png" title="rails初始化过程" alt="图片无法显示" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/23/ubuntuchang-yong-ming-ling/">Ubuntu常用命令</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-23T16:20:00+08:00" pubdate data-updated="true">Oct 23<span>rd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/posts/2013-10-23/ubuntu.jpg" title="ubuntu" alt="无法显示图片" /></p>

<h3>先介绍关于文件和目录的命令：</h3>

<blockquote><p>ls 列出当前目录文件（不包括隐含文件）</p>

<p>ls -a 列出当前目录文件（包括隐含文件）</p>

<p>ls -l 列出当前目录下文件的详细信息</p>

<p>cd .. 回当前目录的上一级目录</p>

<p>cd &ndash; 回上一次所在的目录</p>

<p>cd ~ 或 cd 回当前用户的宿主目录</p>

<p>mkdir 目录名 创建一个目录</p>

<p>rmdir 空目录名 删除一个空目录</p>

<p>rm 文件名 文件名 删除一个文件或多个文件</p>

<p>rm -rf 非空目录名 删除一个非空目录下的一切</p>

<p>mv 路经/文件 /经/文件移动相对路经下的文件到绝对路经下</p>

<p>mv 文件名 新名称 在当前目录下改名</p></blockquote>

<h3>再介绍用户的命令:</h3>

<blockquote><p>useradd 创建一个新的用户</p>

<p>  groupadd 组名 创建一个新的组</p>

<p>  passwd 用户名 为用户创建密码</p>

<p>  passwd -d用户名 删除用户密码也能登陆</p>

<p>  passwd -S用户名 查询账号密码</p>

<p>  usermod -l 新用户名 老用户名 为用户改名</p>

<p>  userdel–r 用户名 删除用户一切</p></blockquote>

<h3>查看系统信息的命令：</h3>

<blockquote><p>uname -a 查看内核版本</p>

<p>cat /etc/issue 查看ubuntu版本</p>

<p>lsusb 查看usb设备</p>

<p>sudo ethtool eth0 查看网卡状态</p>

<p>cat /proc/cpuinfo 查看cpu信息</p>

<p>lshw 查看当前硬件信息</p>

<p>sudo fdisk -l 查看磁盘信息</p>

<p>df -h 查看硬盘剩余空间</p>

<p>free -m 查看当前的内存使用情况</p>

<p>ps -A 查看当前有哪些进程</p></blockquote>

<h3>关于软件包操作的命令：</h3>

<blockquote><p>apt-cache search package 搜索包</p>

<p>  apt-cache show package 获取包的相关信息，如说明、大小、版本等</p>

<p>  sudo apt-get install package 安装包</p>

<p>  sudo apt-get install package &ndash; &ndash; reinstall 重新安装包</p>

<p>  sudo apt-get -f install 修复安装”-f = –fix-missing”</p>

<p>  sudo apt-get remove package 删除包</p>

<p>  sudo apt-get remove package &ndash; &ndash; purge 删除包，包括删除配置文件等</p>

<p>  sudo apt-get update 更新源</p>

<p>  sudo apt-get upgrade 更新已安装的包</p>

<p>  sudo apt-get dist-upgrade 升级系统</p>

<p>  sudo apt-get dselect-upgrade 使用 dselect 升级</p>

<p>  apt-cache depends package 了解使用依赖</p>

<p>  apt-cache rdepends package 是查看该包被哪些包依赖</p>

<p>  sudo apt-get build-dep package 安装相关的编译环境</p>

<p>  apt-get source package 下载该包的源代码</p>

<p>  sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</p>

<p>  sudo apt-get check 检查是否有损坏的依赖</p>

<p>  清理所有软件缓存（即缓存在/var/cache/apt/archives目录里的deb包）</p>

<p>  sudo apt-get clean</p></blockquote>

<h3>最后讲几个比较重要，在实际操作中提供方便的命令：</h3>

<h4>find命令</h4>

<p>  find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。</p>

<p><strong>使用格式如下：</strong></p>

<pre><code>  $ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;
</code></pre>

<ul>
<li><p>&lt;指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。</p></li>
<li><p>&lt;指定条件>： 所要搜索的文件的特征。</p></li>
<li><p>&lt;指定动作>： 对搜索结果进行特定的处理。</p></li>
</ul>


<p><strong>举例：</strong></p>

<pre><code>$ find . -name 'my*' -ls        # 搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。
$ find . -type f -mmin -10    # 搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。
</code></pre>

<hr />

<h4>locate命令</h4>

<p>locate命令其实是&#8221;find -name&#8221;的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</p>

<hr />

<h4>grep命令</h4>

<p>grep命令用于查找文件中的字符串。</p>

<p><strong>命令格式如下：</strong></p>

<pre><code>    grep [选项] 查找模式 [文件名1, 文件名2, ...]

    grep [选项] [-e 查找模式|-f 文件][文件名1, 文件名2, ...]
</code></pre>

<blockquote><p>当然：最好用的参数</p>

<p>  -E 将查找模式解释成正则表达式</p>

<p>  -F 将查找模式解释成单纯的字符串</p>

<p>  -i &mdash;ignore-case 匹配比较时不区分字母的大小</p>

<p>  -R 以递归方式查询目录下所有子目录中的文件</p></blockquote>

<hr />

<h4>ack-grep命令</h4>

<p>grep命令加强。首先，我们先了解什么是ack？</p>

<blockquote><p>  <a href="http://betterthangrep.com">http://betterthangrep.com</a></p>

<p>  ack is a tool <strong>like grep</strong>, optimized for programmers</p>

<p>  is written purely in Perl 5,takes advantage of the power of Perl&rsquo;s regular expressions.</p></blockquote>

<p>ack诞生的目的就是要取代grep。</p>

<p>注意：ubuntu下要安装<strong>ack-grep</strong>，因为在debian系中，ack这个名字被其他的软件占用了。</p>

<pre><code>sudo apt-get install ack-grep
</code></pre>

<hr />

<h4>netstat命令</h4>

<p> Netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>

<p><strong>命令格式如下：</strong></p>

<pre><code>    netstat -tulpn              # 显示服务器进程
    sudo netstat -antup   # 查看进程
    ack-grep function     # 查找函数位置（必须在文件目录下）
</code></pre>

<hr />

<h4>crontab命令</h4>

<p>这个命令我非常喜欢，他是<strong>设置定时执行脚本或任务</strong>,可以用它来定时做一些事情。如定时周期性的备份网站数据库，并email发送到指定邮箱。</p>

<p>参数就几个很简单：</p>

<pre><code>    crontab -l # 显示现有任务条目 
    crontab -r # 删除当前的任务 
    crontab -e # 编辑任务单，一般使用 nano 编辑，如DH。
</code></pre>

<p><strong>时间参数：</strong></p>

<blockquote><p>15 * * * * : 每小时第15分执行1次</p>

<p>15,18 * * * * : 每小时第15和18分各执行1次</p>

<p>*/15 */2 * * *: 每隔15分钟执行1次</p>

<p>15 20 * * 6: 每周星期6的20：15执行1次</p></blockquote>

<hr />
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/22/railsbiao-de-guan-lian/">Rails表的关联</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-22T21:47:00+08:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一段时间没有用到表的关联，回想如何使用时，知识却模糊不清，所以将它记下以便以后查看。
Rails中表的关联主要有三种：单表继承,多态关联,自引用。</p>

<p>个人觉得：</p>

<ul>
<li><p><strong>单表继承</strong>是通过增加<strong>冗余字段</strong>来<strong>减少表的数量</strong>。</p></li>
<li><p><strong>多态关联</strong>是通过建立<strong>虚拟表</strong>来<strong>减少关联数</strong>（belongs_to）和<strong>字段</strong>（外键），方便于以后又有表要关联。</p></li>
<li><p><strong>自引用</strong>也是利用<strong>冗余</strong>而共用<strong>一张表</strong>。</p></li>
</ul>


<p>共同特点：</p>

<blockquote><p>都需要增加type字段，即增加冗余字段。</p></blockquote>

<p>差别：</p>

<blockquote><p>多态可以让子类有自己的行为特征（通过type字段呈现&#8221;多重形态&#8221;）。
单表继承必须拥有共同属性。
自引用必须牺牲一些字段（不需用到的字段的值为null）。</p></blockquote>

<hr />

<h3>详述</h3>

<h4>单表继承：</h4>

<p>一个继承体系<strong>所有类映射到同一张数据库表</strong>，这张表包含<strong>所有类拥有的属性</strong>。记住：所有属性哦，他们可以为null值（:null=>true，即null是可有可无的）。
它通过一个<strong>附加字段type来确认当前记录的对象</strong>属于什么<strong>类型</strong>&mdash;&mdash;ActiveRecord约定。</p>

<p>顾名思义，单表就是一张表，那么怎么呈现多种表的形态呢。当其他表引用它时，可以给予其他名字，但是要声明它实际是那张表(belongs_to :manager, :class_name => &ldquo;Person&rdquo;)，举例：</p>

<p>person.rb:</p>

<pre><code>Class Person &lt; ActiveRecord::Base
        belongs_to XXX
end
</code></pre>

<p>manager.rb:(继承Person类)</p>

<pre><code>Class Manager &lt; Person
end
</code></pre>

<p>rails console:</p>

<pre><code>XXX.first.manager
</code></pre>

<p>mysql:</p>

<pre><code>select people.* from people where people.type in ("Manager") and people.id=1
</code></pre>

<hr />

<h4>多态关联：</h4>

<p>通过建立虚拟表，通过虚拟表（先通过<strong>类型找到关联表</strong>，再通过<strong>外键找到对应的记录</strong>）访问。</p>

<p><strong>举例：</strong></p>

<p>假设我們已经有了Article与Photo这两个Model，然后我们希望这两个Model都可以被留言。不用多态关联的话，你得分別建立ArticleComment和PhotoComment的model。或者一个comment中要有两个外键：article_id和photo_id，虽然用多态也是两个字段，但当表多了就可以看出多态的好处。</p>

<p>现有个场景，有两个model：person和album，需要添加一个图片来做为其头像/封面。添加一个image model，按照以往需要对这几个model做以下关联设置：</p>

<p>没用多态关联前：不复杂，但是麻烦，如果<strong>以后加个book model之类</strong>的，也需要有个图做封面的，那又要<strong>改image model里的关联和migration</strong>了，一点都不DRY。</p>

<pre><code>class Person &lt; ActiveRecord::Base
  has_one :image, :dependent =&gt; :destroy
end

  class Album &lt; ActiveRecord::Base
         has_one :image, :dependent =&gt; :destroy
  end

  class Image &lt; ActiveRecord::Base
     belongs_to :person
         belongs_to :album
end
</code></pre>

<p>相应的image的migration要添加上关联字段：</p>

<pre><code>t.column :person_id, :integer, :null =&gt; false, :default =&gt; 0
    t.column :album_id, :integer, :null =&gt; false, :default =&gt; 0
</code></pre>

<p>使用多态关联后：</p>

<pre><code>    class Person &lt; ActiveRecord::Base
        has_one :image, :as =&gt; :iconable, :dependent =&gt; :destroy
    end
    class Album &lt; ActiveRecord::Base
        has_one :image, :as =&gt; :iconable, :dependent =&gt; :destroy
    end
    class Image &lt; ActiveRecord::Base
        belongs_to :iconable, :polymorphic =&gt; true
    end
</code></pre>

<p>Person和Album有了<strong>共同的一个虚拟的名字</strong>叫做iconable,image表就可以直接用外键iconable_id关联它,</p>

<p><strong>使用方法：</strong></p>

<p>添加：</p>

<pre><code>    @person = Person.new(params[:person])
    @person.build_image(params[:image])
    @person.save
</code></pre>

<p>读取：</p>

<pre><code>    @person.image
</code></pre>

<p>image 的属主：</p>

<pre><code>    @person.iconable
</code></pre>

<hr />

<h4>自引用：</h4>

<p>自引用就是<strong>一条记录可能引用同一张表的另一条记录</strong>：公司员工都有主管，主管也是员工。使用:class_name 和foregin_key加上has_many/has_one和belongs_to.</p>

<pre><code>class Employee &lt; ActiveRecord::Base
    belongs_to :manager,
      :class_name =&gt; "Employee",
      :foregin_key =&gt; "manager_id"
    belongs_to :mentor,
        :class_name =&gt; "Employee",
        :foregin_key =&gt; "mentor_id"
    has_many ：mentored_employees,
      :class_name =&gt; "Employee",
      :foreign_key =&gt; "mentor_id"
    has_many ：managed_employees,
      :class_name =&gt; "Employee",
      :foreign_key =&gt; "manager_id"
end
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/22/vimpei-zhi/">Vim配置</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-22T14:24:00+08:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>说到vim，大家应该都不陌生。它是类似于vi的编辑器，在vi的基础上增加了很多新特性。</p>

<p><img src="/images/posts/2013-10-22/vim.jpg" title="Vim图" alt="图片无法显示" /></p>

<h4>.vimrc配置文件</h4>

<p>以下内容复制到用户目录下的.vimrc文件，可以更改vim配置，使Vim更美观，更好用:</p>

<pre><code>set nocompatible            " 关闭 vi 兼容模式
    syntax on                   " 自动语法高亮
    colorscheme molokai         " 设定配色方案
    set number                  " 显示行号
    set cursorline              " 突出显示当前行
    set ruler                   " 打开状态栏标尺
    set shiftwidth=4            " 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4
    set softtabstop=4           " 使得按退格键时可以一次删掉 4 个空格
    set tabstop=4               " 设定 tab 长度为 4
    set nobackup                " 覆盖文件时不备份
    set autochdir               " 自动切换当前目录为当前文件所在的目录
    filetype plugin indent on   " 开启插件
    set backupcopy=yes          " 设置备份时的行为为覆盖
    set ignorecase smartcase    " 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感
    set nowrapscan              " 禁止在搜索到文件两端时重新搜索
    set incsearch               " 输入搜索内容时就显示搜索结果
    set hlsearch                " 搜索时高亮显示被找到的文本
    set noerrorbells            " 关闭错误信息响铃
    set novisualbell            " 关闭使用可视响铃代替呼叫
    set t_vb=                   " 置空错误铃声的终端代码
    " set showmatch               " 插入括号时，短暂地跳转到匹配的对应括号
    " set matchtime=2             " 短暂跳转到匹配括号的时间
    set magic                   " 设置魔术
    set hidden                  " 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存
    set guioptions-=T           " 隐藏工具栏  （等号前后不能空格）
    set guioptions-=m           " 隐藏菜单栏
    set smartindent             " 开启新行时使用智能自动缩进
    set backspace=indent,eol,start
                                                            " 不设定在插入状态无法用退格键和 Delete 键删除回车符
    set cmdheight=1             " 设定命令行的行数为 1
    set laststatus=2            " 显示状态栏 (默认值为 1, 无法显示状态栏)
    set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding}\ %c:%l/%L%)\ 
                                                            " 设置在状态行显示的信息
    set foldenable              " 开始折叠
    set foldmethod=syntax       " 设置语法折叠

    "窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动
    "光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的
    "时候会变得非常方便.
    nnoremap &lt;C-h&gt; &lt;C-w&gt;h
    nnoremap &lt;C-j&gt; &lt;C-w&gt;j
    nnoremap &lt;C-k&gt; &lt;C-w&gt;k
    nnoremap &lt;C-l&gt; &lt;C-w&gt;l
</code></pre>

<p>接下来是括号补全：</p>

<pre><code>    inoremap (  ()&lt;Esc&gt;i                " inoremap表示输入模式下的匹配,当有"("时，匹配")"并退出重新进入"i编辑模式"
    inoremap [  []&lt;Esc&gt;i
    inoremap {  {}&lt;Esc&gt;i
    autocmd Syntax html,vim inoremap &lt; &lt;lt&gt;&gt;&lt;Esc&gt;i | inoremap &gt; &lt;c-r&gt;=ClosePair('&gt;')&lt;CR&gt;
    inoremap ) &lt;c-r&gt;=ClosePair(')')&lt;CR&gt;
    inoremap ] &lt;c-r&gt;=ClosePair(']')&lt;CR&gt;
    inoremap } &lt;c-r&gt;=CloseBracket()&lt;CR&gt;
    inoremap " &lt;c-r&gt;=QuoteDelim('"')&lt;CR&gt;
    inoremap ' &lt;c-r&gt;=QuoteDelim("'")&lt;CR&gt;

    function ClosePair(char)
        if getline('.')[col('.') - 1] == a:char
            return "\&lt;Right&gt;"
        else
            return a:char
        endif
    endf

    function CloseBracket()
        if match(getline('.' + 1), '\s*}') &lt; 0
            return "\&lt;CR&gt;}"
        else
            return "\&lt;Esc&gt;j0f}a"
        endif
    endf

    function QuoteDelim(char)
        let line = getline('.')
        let col = col('.')
        if line[col-2] == "\\"
            "Inserting a quoted quotation mark into string
            return a:char
        elseif line[col-1] == a:char
            "Escaping out of the string
            return "\&lt;Right&gt;"
        else
            "Starting a String
            return a:char.a:char."\&lt;Esc&gt;i"
        endif
    endf
</code></pre>

<p>下列两款vim插件非常好用，安装完，也必须在.vimrc中添加如下内容：</p>

<pre><code>    "-----------------------------------------------------------------
    " plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录
    " :ERDtree 打开NERD_tree         :NERDtreeClose    关闭NERD_tree
    " o 打开关闭文件或者目录         t 在标签页中打开
    " T 在后台标签页中打开           ! 执行此文件
    " p 到上层目录                   P 到根目录
    " K 到第一个节点                 J 到最后一个节点
    " u 打开上层目录                 m 显示文件系统菜单（添加、删除、移动操作）
    " r 递归刷新当前目录             R 递归刷新当前根目录
    "-----------------------------------------------------------------
    " F3 NERDTree 切换
    map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;
    imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;


    "-----------------------------------------------------------------
    " plugin - NERD_commenter.vim   注释代码用的，
    " [count],cc 光标以下count行逐行添加注释(7,cc)
    " [count],cu 光标以下count行逐行取消注释(7,cu)
    " [count],cm 光标以下count行尝试添加块注释(7,cm)
    " ,cA 在行尾插入 /* */,并且进入插入模式。 这个命令方便写注释。
    " 注：count参数可选，无则默认为选中行或当前行
    "-----------------------------------------------------------------
    let NERDSpaceDelims=1       " 让注释符与语句之间留一个空格
    let NERDCompactSexyComs=1   " 多行注释时样子更好看
</code></pre>

<p><em>感谢使用vim配置，记住要将vim编辑器重启后才生效。</em></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/03/04/tuan-dui-guan-li/">团队管理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/25/min-jie-kai-fa/">敏捷开发</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/07/linuxyong-hu-he-quan-xian/">Linux用户和权限</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/06/xiang-mu-dai-ma-shi-xian/">项目代码实现</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/10/26/rails-assets-pipeline/">Rails Assets Pipeline</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - TsaiKoga -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'tsaikogablog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
