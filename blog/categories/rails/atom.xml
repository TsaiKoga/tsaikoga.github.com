<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | TsaiKoga Blog]]></title>
  <link href="http://TsaiKoga.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://TsaiKoga.github.com/"/>
  <updated>2013-10-25T22:52:03+08:00</updated>
  <id>http://TsaiKoga.github.com/</id>
  <author>
    <name><![CDATA[TsaiKoga]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails初始化和启动过程]]></title>
    <link href="http://TsaiKoga.github.com/blog/2013/10/24/railschu-shi-hua-he-qi-dong-guo-cheng/"/>
    <updated>2013-10-24T14:51:00+08:00</updated>
    <id>http://TsaiKoga.github.com/blog/2013/10/24/railschu-shi-hua-he-qi-dong-guo-cheng</id>
    <content type="html"><![CDATA[<p>我们都知道，每当我们console中输入rails s时，系统就启动了你的rails应用程序。</p>

<hr />

<h3>app程序中的bin/rails脚本</h3>

<p>它是由你的app程序的<strong>bin/rails脚本</strong>执行的(我们的rails命令在通过bin/rails脚本引用rails/commands.rb文件中)。</p>

<p><em>如：example_</em>app/bin/rails_</p>

<pre><code>    #!/usr/bin/env ruby
    APP_PATH = File.expand_path('../../config/application',  __FILE__)
    require_relative '../config/boot'
    require 'rails/commands'
</code></pre>

<p>APP_PATH常量将会在rails/commands中用到，而config/boot指向<strong>config/boot.rb</strong>文件，这个文件<strong>会加载和设置Bundler</strong>。</p>

<hr />

<h3>config/boot.rb加载gem</h3>

<p>前面bin/rails引入两个文件,现在我们先说第一个文件
config/boot.rb:</p>

<pre><code>    # Set up gems listed in the Gemfile.
    ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)

    require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])
</code></pre>

<p>config/boot.rb用ENV[&lsquo;BUNDLE_GEMFILE&rsquo;]定位Gemfile文件，当Gemfile文件存在时，就将它引入。这样一来，gem就被引入了。</p>

<hr />

<h3>rails/commands.rb执行rails命令</h3>

<p>前面config/boot.rb引入的第二个文件,但这个文件必须在第一个文件config/boot.rb文件引入后才被引入。
rails/commands.rb:</p>

<pre><code>    ARGV &lt;&lt; '--help' if ARGV.empty?

    aliases = {
        "g"  =&gt; "generate",
        "d"  =&gt; "destroy",
        "c"  =&gt; "console",
        "s"  =&gt; "server",
        "db" =&gt; "dbconsole",
        "r"  =&gt; "runner"
    }

    command = ARGV.shift
    command = aliases[command] || command
</code></pre>

<p>当你输入的是rails server的话，将会执行下列代码匹配你的命令：</p>

<pre><code>    when 'server'
        # Change to the application's path if there is no config.ru file in current dir.
        # This allows us to run `rails server` from other directories, but still get
        # the main config.ru and properly set the tmp directory.
        Dir.chdir(File.expand_path('../../', APP_PATH)) unless File.exists?(File.expand_path("config.ru"))

        require 'rails/commands/server'
        Rails::Server.new.tap do |server|
            # We need to require application after the server sets environment,
            # otherwise the --environment option given to the server won't propagate.
            require APP_PATH
            Dir.chdir(Rails.application.root)
            server.start
        end
</code></pre>

<p>刚才我们的bin/rails脚本中已经定义了常量APP_PATH为"config/application.rb",而Dir.chdir(File.expand_path(&lsquo;../../&rsquo;, APP_PATH)) unless File.exists?(File.expand_path(&ldquo;config.ru&rdquo;))表示如果<strong>没有config.ru文件时，就加载rails/commands/server文件，否则加载config/application.rb</strong>。</p>

<p>也就是，你<strong>启动了服务前才帮你加载程序的应用文件application.rb</strong>。
application.rb这个文件将会加载Rails。</p>

<hr />

<h3>rails/commands/server.rb</h3>

<p>来看一下rails/commands/server中定义的类Rails::Server吧。</p>

<pre><code>    require 'fileutils'
    require 'optparse'
    require 'action_dispatch'

    module Rails
        class Server &lt; ::Rack::Server
</code></pre>

<p>这里引入的<strong>fileutils和optparse</strong>是<strong>标准的ruby库</strong>，分别提供文件的辅助方法和转化选择。</p>

<p>Rails::Server继承了Rack::Server,当<strong>Rack::Server被初始化(设置环境)</strong>时，Rack::Server也被初始化。</p>

<pre><code>    def initialize(*)
        super
        set_environment
    end
</code></pre>

<hr />

<p>Rack::Server是为<strong>以Rack为基础的应用提供公用的服务接口</strong>，rails就是其中之一。</p>

<ul>
<li><p>初始化设置环境：</p>

<p>  刚才提到的初始化代码如下：</p>

<pre><code>  def set_environment
      ENV["RAILS_ENV"] ||= options[:environment]
  end
</code></pre>

<p>  不要以为set_environment很少，options干了很多事情：</p>

<pre><code>  def options
      @options ||= parse_options(ARGV)
  end
</code></pre>

<p>  parse_options定义如下：</p>

<pre><code>  def parse_options(args)
      options = default_options

      # Don't evaluate CGI ISINDEX parameters.
      # http://hoohoo.ncsa.uiuc.edu/cgi/cl.html
      args.clear if ENV.include?("REQUEST_METHOD")

      options.merge! opt_parser.parse! args
      options[:config] = ::File.expand_path(options[:config])
      ENV["RACK_ENV"] = options[:environment]
      options
  end
</code></pre>

<p>  我们将一行一行解释，</p>

<p>  (1)选择default_options如下设置：</p>

<pre><code>  def default_options
      {
          :environment =&gt; ENV['RACK_ENV'] || "development",
          :pid         =&gt; nil,
          :Port        =&gt; 9292,
          :Host        =&gt; "0.0.0.0",
          :AccessLog   =&gt; [],
          :config      =&gt; "config.ru"
      }
  end
</code></pre>

<p>  它<strong>(Rack::Server)提供了默认环境和端口号等信息</strong>，还记得当rails/commands.rb中，如果存在config.ru时，就加载config/applicaton.rb文件吗？</p>

<p>  (2)当ENV哈希环境中没有REQUEST_METHOD这个键时，跳过而去执行合并选项。</p>

<p>  Rack::Server中的opt_server</p>

<pre><code>  def opt_parser
      Options.new
  end
</code></pre>

<p>  (3)Rails::Server重写parse!</p>

<pre><code>  def parse!(args)
      args, options = args.dup, {}

      opt_parser = OptionParser.new do |opts|
          opts.banner = "Usage: rails server [mongrel, thin, etc] [options]"
          opts.on("-p", "--port=port", Integer,
                          "Runs Rails on the specified port.", "Default: 3000") { |v| options[:Port] = v }
      ...
</code></pre></li>
</ul>


<p>刚才说default_options已经有了config.ru，这是回到之前rails.commands.rb文件，它加载了config/application.rb文件</p>

<hr />

<h3>config/application.rb</h3>

<p>当require APP_PATH被执行，<strong>config/applicaton.rb被加载，server.start就被调用</strong>了。
方法如下：</p>

<pre><code>    def start
        url = "#{options[:SSLEnable] ? 'https' : 'http'}://#{options[:Host]}:#{options[:Port]}"
        puts "=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}"
        puts "=&gt; Rails #{Rails.version} application starting in #{Rails.env} on #{url}"
        puts "=&gt; Run `rails server -h` for more startup options"
        trap(:INT) { exit }
        puts "=&gt; Ctrl-C to shutdown server" unless options[:daemonize]

        #Create required tmp directories if not found
        %w(cache pids sessions sockets).each do |dir_to_make|
            FileUtils.mkdir_p(Rails.root.join('tmp', dir_to_make))
        end

        unless options[:daemonize]
            wrapped_app # touch the app so the logger is set up

            console = ActiveSupport::Logger.new($stdout)
            console.formatter = Rails.logger.formatter

            Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
        end

        super
    ensure
        # The '-h' option calls exit before @options is set.
        # If we call 'options' with it unset, we get double help banners.
        puts 'Exiting' unless @options &amp;&amp; options[:daemonize]
    end
</code></pre>

<blockquote><ul>
<li><p>这个方法非常重要，我们可以看到前面有一堆提示，而后面<strong>创建了tmp/cache,tmp/pids,tmp/sessions和tmp/sockets文件夹</strong>,</p></li>
<li><p>在调用<strong>wrapped_app方法创建Rack应用</strong>。</p></li>
<li><p>并且<strong>定了ActiveSupport::Logger</strong>。</p></li>
</ul>
</blockquote>

<p>还记得<strong>options[:config]默认指向config.ru</strong>吗？这个文件中包含了：</p>

<pre><code>    # This file is used by Rack-based servers to start the application.

    require ::File.expand_path('../config/environment',  __FILE__)
    run &lt;%= app_const %&gt;
</code></pre>

<p>它<strong>引进了config/environment.rb</strong>文件，而<strong>environment.rb这个文件引入了config/application.rb</strong>文件</p>

<hr />

<h3>actionpack/lib/action_dispatch.rb</h3>

<p>Action Dispatch是rails框架的一个路由组件，提供routing,session和middlewares</p>

<p>也就是，你启动了服务前才帮你加载程序的应用文件application.rb。</p>

<hr />

<h4>总结：(自己所画的rails初始化过程图片)</h4>

<p><img src="/images/posts/2013-10-23/rails_initialize.png" title="rails初始化过程" alt="图片无法显示" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails表的关联]]></title>
    <link href="http://TsaiKoga.github.com/blog/2013/10/22/railsbiao-de-guan-lian/"/>
    <updated>2013-10-22T21:47:00+08:00</updated>
    <id>http://TsaiKoga.github.com/blog/2013/10/22/railsbiao-de-guan-lian</id>
    <content type="html"><![CDATA[<p>一段时间没有用到表的关联，回想如何使用时，知识却模糊不清，所以将它记下以便以后查看。
Rails中表的关联主要有三种：单表继承,多态关联,自引用。</p>

<p>个人觉得：</p>

<ul>
<li><p><strong>单表继承</strong>是通过增加<strong>冗余字段</strong>来<strong>减少表的数量</strong>。</p></li>
<li><p><strong>多态关联</strong>是通过建立<strong>虚拟表</strong>来<strong>减少关联数</strong>（belongs_to）和<strong>字段</strong>（外键），方便于以后又有表要关联。</p></li>
<li><p><strong>自引用</strong>也是利用<strong>冗余</strong>而共用<strong>一张表</strong>。</p></li>
</ul>


<p>共同特点：</p>

<blockquote><p>都需要增加type字段，即增加冗余字段。</p></blockquote>

<p>差别：</p>

<blockquote><p>多态可以让子类有自己的行为特征（通过type字段呈现"多重形态"）。
单表继承必须拥有共同属性。
自引用必须牺牲一些字段（不需用到的字段的值为null）。</p></blockquote>

<hr />

<h3>详述</h3>

<h4>单表继承：</h4>

<p>一个继承体系<strong>所有类映射到同一张数据库表</strong>，这张表包含<strong>所有类拥有的属性</strong>。记住：所有属性哦，他们可以为null值（:null=>true，即null是可有可无的）。
它通过一个<strong>附加字段type来确认当前记录的对象</strong>属于什么<strong>类型</strong>&mdash;&mdash;ActiveRecord约定。</p>

<p>顾名思义，单表就是一张表，那么怎么呈现多种表的形态呢。当其他表引用它时，可以给予其他名字，但是要声明它实际是那张表(belongs_to :manager, :class_name => &ldquo;Person&rdquo;)，举例：</p>

<p>person.rb:</p>

<pre><code>Class Person &lt; ActiveRecord::Base
        belongs_to XXX
end
</code></pre>

<p>manager.rb:(继承Person类)</p>

<pre><code>Class Manager &lt; Person
end
</code></pre>

<p>rails console:</p>

<pre><code>XXX.first.manager
</code></pre>

<p>mysql:</p>

<pre><code>select people.* from people where people.type in ("Manager") and people.id=1
</code></pre>

<hr />

<h4>多态关联：</h4>

<p>通过建立虚拟表，通过虚拟表（先通过<strong>类型找到关联表</strong>，再通过<strong>外键找到对应的记录</strong>）访问。</p>

<p><strong>举例：</strong></p>

<p>假设我們已经有了Article与Photo这两个Model，然后我们希望这两个Model都可以被留言。不用多态关联的话，你得分別建立ArticleComment和PhotoComment的model。或者一个comment中要有两个外键：article_id和photo_id，虽然用多态也是两个字段，但当表多了就可以看出多态的好处。</p>

<p>现有个场景，有两个model：person和album，需要添加一个图片来做为其头像/封面。添加一个image model，按照以往需要对这几个model做以下关联设置：</p>

<p>没用多态关联前：不复杂，但是麻烦，如果<strong>以后加个book model之类</strong>的，也需要有个图做封面的，那又要<strong>改image model里的关联和migration</strong>了，一点都不DRY。</p>

<pre><code>class Person &lt; ActiveRecord::Base
  has_one :image, :dependent =&gt; :destroy
end

  class Album &lt; ActiveRecord::Base
         has_one :image, :dependent =&gt; :destroy
  end

  class Image &lt; ActiveRecord::Base
     belongs_to :person
         belongs_to :album
end
</code></pre>

<p>相应的image的migration要添加上关联字段：</p>

<pre><code>t.column :person_id, :integer, :null =&gt; false, :default =&gt; 0
    t.column :album_id, :integer, :null =&gt; false, :default =&gt; 0
</code></pre>

<p>使用多态关联后：</p>

<pre><code>    class Person &lt; ActiveRecord::Base
        has_one :image, :as =&gt; :iconable, :dependent =&gt; :destroy
    end
    class Album &lt; ActiveRecord::Base
        has_one :image, :as =&gt; :iconable, :dependent =&gt; :destroy
    end
    class Image &lt; ActiveRecord::Base
        belongs_to :iconable, :polymorphic =&gt; true
    end
</code></pre>

<p>Person和Album有了<strong>共同的一个虚拟的名字</strong>叫做iconable,image表就可以直接用外键iconable_id关联它,</p>

<p><strong>使用方法：</strong></p>

<p>添加：</p>

<pre><code>    @person = Person.new(params[:person])
    @person.build_image(params[:image])
    @person.save
</code></pre>

<p>读取：</p>

<pre><code>    @person.image
</code></pre>

<p>image 的属主：</p>

<pre><code>    @person.iconable
</code></pre>

<hr />

<h4>自引用：</h4>

<p>自引用就是<strong>一条记录可能引用同一张表的另一条记录</strong>：公司员工都有主管，主管也是员工。使用:class_name 和foregin_key加上has_many/has_one和belongs_to.</p>

<pre><code>class Employee &lt; ActiveRecord::Base
    belongs_to :manager,
      :class_name =&gt; "Employee",
      :foregin_key =&gt; "manager_id"
    belongs_to :mentor,
        :class_name =&gt; "Employee",
        :foregin_key =&gt; "mentor_id"
    has_many ：mentored_employees,
      :class_name =&gt; "Employee",
      :foreign_key =&gt; "mentor_id"
    has_many ：managed_employees,
      :class_name =&gt; "Employee",
      :foreign_key =&gt; "manager_id"
end
</code></pre>
]]></content>
  </entry>
  
</feed>
