<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | TsaiKoga Blog]]></title>
  <link href="http://TsaiKoga.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://TsaiKoga.github.com/"/>
  <updated>2013-10-26T09:38:25+08:00</updated>
  <id>http://TsaiKoga.github.com/</id>
  <author>
    <name><![CDATA[TsaiKoga]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[加载Rails]]></title>
    <link href="http://TsaiKoga.github.com/blog/2013/10/25/jia-zai-rails/"/>
    <updated>2013-10-25T22:58:00+08:00</updated>
    <id>http://TsaiKoga.github.com/blog/2013/10/25/jia-zai-rails</id>
    <content type="html"><![CDATA[<p>在上一篇文章<a href="http://tsaikoga.github.io/blog/2013/10/24/railschu-shi-hua-he-qi-dong-guo-cheng/">Rails服务启动过程</a>,最后加载的config/application.rb文件中显示：</p>

<pre><code>    require 'rails/all'
</code></pre>

<p>这个文件在railties/lib/rails/all.rb。</p>

<hr />

<h3>railties/lib/rails/all.rb</h3>

<p>这个文件非常重要，它加载了rails的所有个体框架，从中可以知道这些<strong>框架的加载顺序</strong>：</p>

<pre><code>require "rails"

    %{
        active_record
        action_controller
        action_mail
        rails/test_unit
        sprockets
    }.each do |framework|
        begin
            require "#{framework}/railtie"          # 文件active_record/railtie等
      rescue LoadError
        end
    end
</code></pre>

<blockquote><p><strong>railtie 是Rails的核心框架</strong>，并且提供hooks来修改启动时的载入流程，
如果需要在启动过程或之后与rails框架进行交互，就需要加载Railtie。</p></blockquote>

<hr />

<h3>config/environment.rb</h3>

<p>当config/application.rb已经将rails加载完成,并且<strong>定义了应用的命名空间</strong>（在一个module中mixin一个Application类）。</p>

<p>而在config/environment.rb文件中，你的<strong>项目被初始化</strong>，如：<strong>Examples::Application.initialize!(在application.rb中已经定义了)</strong>。</p>

<p>想知道初始化做了写什么吗？</p>

<hr />

<h3>railties/lib/rails/application.rb</h3>

<p>以下为初始化代码：(你的Application类继承Rails::Application类，而这个类就在railties/lib/rails/application.rb文件中)</p>

<pre><code>    def initialize!(group=:default) #:nodoc:
        raise "Application has been already initialized." if @initialized
        run_initializers(group, self)
        @initialized = true
        self
    end
</code></pre>

<p>Rails会贯穿这整个Rails::Application祖先类，重新排序和运行他们。</p>

<h3>Rack: lib/rack/server.rb</h3>

<p>在<a href="http://tsaikoga.github.io/blog/2013/10/24/railschu-shi-hua-he-qi-dong-guo-cheng/">上一篇</a>时,有提到Rack::Server类，它里面有一个app方法是这么定义的：</p>

<pre><code>    def app
        @app ||= begin
            if !::File.exist? options[:config]
                abort "configuration #{options[:config]} not found"
            end

            app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
            self.options.merge! options
            app
        end
    end
</code></pre>

<p>这里所指的app就是Rails的app（一种中间件），Rack将会调用所有提供的中间件。</p>

<pre><code>    def build_app(app)
        middleware[options[:environment]].reverse_each do |middleware|
            middleware = middleware.call(self) if middleware.respond_to?(:call)
            next unless middleware
            klass = middleware.shift
            app = klass.new(app, *middleware)
        end
        app
    end
</code></pre>

<p>以上代码build_app是被Server#start方法调用的，通过这个代码调用：</p>

<pre><code>    server.run wrapped_app, options, &amp;blk
</code></pre>

<p>所以，server.run将会依赖于你所使用的server程序(以上代码有传入一个程序块&amp;blk,他将关系到你运行的服务),
像是如果你是用的是Mongrel数据库，将会通过传入如下程序块运行：</p>

<pre><code>    def self.run(app, options={})
        server = ::Mongrel::HttpServer.new(
            options[:Host]           || '0.0.0.0',
            options[:Port]           || 8080,
            options[:num_processors] || 950,
            options[:throttle]       || 0,
            options[:timeout]        || 60)
        # Acts like Rack::URLMap, utilizing Mongrel's own path finding methods.
        # Use is similar to #run, replacing the app argument with a hash of
        # { path=&gt;app, ... } or an instance of Rack::URLMap.
        if options[:map]
            if app.is_a? Hash
                app.each do |path, appl|
                    path = '/'+path unless path[0] == ?/
                    server.register(path, Rack::Handler::Mongrel.new(appl))
                end
            elsif app.is_a? URLMap
                app.instance_variable_get(:@mapping).each do |(host, path, appl)|
                 next if !host.nil? &amp;&amp; !options[:Host].nil? &amp;&amp; options[:Host] != host
                 path = '/'+path unless path[0] == ?/
                 server.register(path, Rack::Handler::Mongrel.new(appl))
                end
            else
                raise ArgumentError, "first argument should be a Hash or URLMap"
            end
        else
            server.register('/', Rack::Handler::Mongrel.new(app))
        end
        yield server  if block_given?
        server.run.join
    end
</code></pre>

<p>以上代码使用Mongrel::HttpServer定义了server实例，然后使用server.run运行.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails服务启动过程]]></title>
    <link href="http://TsaiKoga.github.com/blog/2013/10/24/railschu-shi-hua-he-qi-dong-guo-cheng/"/>
    <updated>2013-10-24T14:51:00+08:00</updated>
    <id>http://TsaiKoga.github.com/blog/2013/10/24/railschu-shi-hua-he-qi-dong-guo-cheng</id>
    <content type="html"><![CDATA[<p>我们都知道，每当我们console中输入rails s时，系统就启动了你的rails应用程序。</p>

<hr />

<h3>app程序中的bin/rails脚本</h3>

<p>它是由你的app程序的<strong>bin/rails脚本</strong>执行的(我们的rails命令在通过bin/rails脚本引用rails/commands.rb文件中)。</p>

<p><em>如：example_</em>app/bin/rails_</p>

<pre><code>    #!/usr/bin/env ruby
    APP_PATH = File.expand_path('../../config/application',  __FILE__)
    require_relative '../config/boot'
    require 'rails/commands'
</code></pre>

<p>APP_PATH常量将会在rails/commands中用到，而config/boot指向<strong>config/boot.rb</strong>文件，这个文件<strong>会加载和设置Bundler</strong>。</p>

<hr />

<h3>config/boot.rb加载gem</h3>

<p>前面bin/rails引入两个文件,现在我们先说第一个文件
config/boot.rb:</p>

<pre><code>    # Set up gems listed in the Gemfile.
    ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)

    require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])
</code></pre>

<p>config/boot.rb用ENV[&lsquo;BUNDLE_GEMFILE&rsquo;]定位Gemfile文件，当Gemfile文件存在时，就将它引入。这样一来，gem就被引入了。</p>

<hr />

<h3>rails/commands.rb执行rails命令</h3>

<p>前面config/boot.rb引入的第二个文件,但这个文件必须在第一个文件config/boot.rb文件引入后才被引入。
rails/commands.rb:</p>

<pre><code>    ARGV &lt;&lt; '--help' if ARGV.empty?

    aliases = {
        "g"  =&gt; "generate",
        "d"  =&gt; "destroy",
        "c"  =&gt; "console",
        "s"  =&gt; "server",
        "db" =&gt; "dbconsole",
        "r"  =&gt; "runner"
    }

    command = ARGV.shift
    command = aliases[command] || command
</code></pre>

<p>当你输入的是rails server的话，将会执行下列代码匹配你的命令：</p>

<pre><code>    when 'server'
        # Change to the application's path if there is no config.ru file in current dir.
        # This allows us to run `rails server` from other directories, but still get
        # the main config.ru and properly set the tmp directory.
        Dir.chdir(File.expand_path('../../', APP_PATH)) unless File.exists?(File.expand_path("config.ru"))

        require 'rails/commands/server'
        Rails::Server.new.tap do |server|
            # We need to require application after the server sets environment,
            # otherwise the --environment option given to the server won't propagate.
            require APP_PATH
            Dir.chdir(Rails.application.root)
            server.start
        end
</code></pre>

<p>刚才我们的bin/rails脚本中已经定义了常量APP_PATH为"config/application.rb",而</p>

<pre><code>    Dir.chdir(File.expand\_path('../../', APP\_PATH)) unless File.exists?(File.expand\_path("config.ru"))
</code></pre>

<p>表示如果<strong>没有config.ru文件时，就加载rails/commands/server文件，否则加载config/application.rb</strong>。</p>

<p>也就是，你<strong>启动了服务前才帮你加载程序的应用文件application.rb</strong>。
application.rb这个文件将会加载Rails。</p>

<hr />

<h3>rails/commands/server.rb</h3>

<p>来看一下rails/commands/server中定义的类Rails::Server吧。</p>

<pre><code>    require 'fileutils'
    require 'optparse'
    require 'action_dispatch'

    module Rails
        class Server &lt; ::Rack::Server
</code></pre>

<p>这里引入的<strong>fileutils和optparse</strong>是<strong>标准的ruby库</strong>，分别提供文件的辅助方法和转化选择。</p>

<p>Rails::Server继承了Rack::Server,当<strong>Rack::Server被初始化(设置环境)</strong>时，Rack::Server也被初始化。</p>

<pre><code>    def initialize(*)
        super
        set_environment
    end
</code></pre>

<hr />

<p>Rack::Server是为<strong>以Rack为基础的应用提供公用的服务接口</strong>，rails就是其中之一。</p>

<ul>
<li><p>初始化设置环境：</p>

<p>  刚才提到的初始化代码如下：</p>

<pre><code>  def set_environment
      ENV["RAILS_ENV"] ||= options[:environment]
  end
</code></pre>

<p>  不要以为set_environment很少，options干了很多事情：</p>

<pre><code>  def options
      @options ||= parse_options(ARGV)
  end
</code></pre>

<p>  parse_options定义如下：</p>

<pre><code>  def parse_options(args)
      options = default_options

      # Don't evaluate CGI ISINDEX parameters.
      # http://hoohoo.ncsa.uiuc.edu/cgi/cl.html
      args.clear if ENV.include?("REQUEST_METHOD")

      options.merge! opt_parser.parse! args
      options[:config] = ::File.expand_path(options[:config])
      ENV["RACK_ENV"] = options[:environment]
      options
  end
</code></pre>

<p>  我们将一行一行解释，</p>

<p>  (1)选择default_options如下设置：</p>

<pre><code>  def default_options
      {
          :environment =&gt; ENV['RACK_ENV'] || "development",
          :pid         =&gt; nil,
          :Port        =&gt; 9292,
          :Host        =&gt; "0.0.0.0",
          :AccessLog   =&gt; [],
          :config      =&gt; "config.ru"
      }
  end
</code></pre>

<p>  它<strong>(Rack::Server)提供了默认环境和端口号等信息</strong>，还记得当rails/commands.rb中，如果存在config.ru时，就加载config/applicaton.rb文件吗？</p>

<p>  (2)当ENV哈希环境中没有REQUEST_METHOD这个键时，跳过而去执行合并选项。</p>

<p>  Rack::Server中的opt_server</p>

<pre><code>  def opt_parser
      Options.new
  end
</code></pre>

<p>  (3)Rails::Server重写parse!</p>

<pre><code>  def parse!(args)
      args, options = args.dup, {}

      opt_parser = OptionParser.new do |opts|
          opts.banner = "Usage: rails server [mongrel, thin, etc] [options]"
          opts.on("-p", "--port=port", Integer,
                          "Runs Rails on the specified port.", "Default: 3000") { |v| options[:Port] = v }
      ...
</code></pre></li>
</ul>


<p>刚才说default_options已经有了config.ru，这是回到之前rails.commands.rb文件，它加载了config/application.rb文件</p>

<hr />

<h3>config/application.rb</h3>

<p>当require APP_PATH被执行，<strong>config/applicaton.rb被加载，server.start就被调用</strong>了。
方法如下：</p>

<pre><code>    def start
        url = "#{options[:SSLEnable] ? 'https' : 'http'}://#{options[:Host]}:#{options[:Port]}"
        puts "=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}"
        puts "=&gt; Rails #{Rails.version} application starting in #{Rails.env} on #{url}"
        puts "=&gt; Run `rails server -h` for more startup options"
        trap(:INT) { exit }
        puts "=&gt; Ctrl-C to shutdown server" unless options[:daemonize]

        #Create required tmp directories if not found
        %w(cache pids sessions sockets).each do |dir_to_make|
            FileUtils.mkdir_p(Rails.root.join('tmp', dir_to_make))
        end

        unless options[:daemonize]
            wrapped_app # touch the app so the logger is set up

            console = ActiveSupport::Logger.new($stdout)
            console.formatter = Rails.logger.formatter

            Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
        end

        super
    ensure
        # The '-h' option calls exit before @options is set.
        # If we call 'options' with it unset, we get double help banners.
        puts 'Exiting' unless @options &amp;&amp; options[:daemonize]
    end
</code></pre>

<blockquote><ul>
<li><p>这个方法非常重要，我们可以看到前面有一堆提示，而后面<strong>创建了tmp/cache,tmp/pids,tmp/sessions和tmp/sockets文件夹</strong>,</p></li>
<li><p>在调用<strong>wrapped_app方法创建Rack应用</strong>。</p></li>
<li><p>并且<strong>定了ActiveSupport::Logger</strong>。</p></li>
</ul>
</blockquote>

<p>还记得<strong>options[:config]默认指向config.ru</strong>吗？这个文件中包含了：</p>

<pre><code>    # This file is used by Rack-based servers to start the application.

    require ::File.expand_path('../config/environment',  __FILE__)
    run &lt;%= app_const %&gt;
</code></pre>

<p>它<strong>引进了config/environment.rb</strong>文件，而<strong>environment.rb这个文件引入了config/application.rb</strong>文件</p>

<hr />

<h3>actionpack/lib/action_dispatch.rb</h3>

<p>Action Dispatch是rails框架的一个路由组件，提供routing,session和middlewares</p>

<p>也就是，你启动了服务前才帮你加载程序的应用文件application.rb。</p>

<hr />

<h4>总结：(自己所画的rails初始化过程图片)</h4>

<p><img src="/images/posts/2013-10-23/rails_initialize.png" title="rails初始化过程" alt="图片无法显示" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails表的关联]]></title>
    <link href="http://TsaiKoga.github.com/blog/2013/10/22/railsbiao-de-guan-lian/"/>
    <updated>2013-10-22T21:47:00+08:00</updated>
    <id>http://TsaiKoga.github.com/blog/2013/10/22/railsbiao-de-guan-lian</id>
    <content type="html"><![CDATA[<p>一段时间没有用到表的关联，回想如何使用时，知识却模糊不清，所以将它记下以便以后查看。
Rails中表的关联主要有三种：单表继承,多态关联,自引用。</p>

<p>个人觉得：</p>

<ul>
<li><p><strong>单表继承</strong>是通过增加<strong>冗余字段</strong>来<strong>减少表的数量</strong>。</p></li>
<li><p><strong>多态关联</strong>是通过建立<strong>虚拟表</strong>来<strong>减少关联数</strong>（belongs_to）和<strong>字段</strong>（外键），方便于以后又有表要关联。</p></li>
<li><p><strong>自引用</strong>也是利用<strong>冗余</strong>而共用<strong>一张表</strong>。</p></li>
</ul>


<p>共同特点：</p>

<blockquote><p>都需要增加type字段，即增加冗余字段。</p></blockquote>

<p>差别：</p>

<blockquote><p>多态可以让子类有自己的行为特征（通过type字段呈现"多重形态"）。
单表继承必须拥有共同属性。
自引用必须牺牲一些字段（不需用到的字段的值为null）。</p></blockquote>

<hr />

<h3>详述</h3>

<h4>单表继承：</h4>

<p>一个继承体系<strong>所有类映射到同一张数据库表</strong>，这张表包含<strong>所有类拥有的属性</strong>。记住：所有属性哦，他们可以为null值（:null=>true，即null是可有可无的）。
它通过一个<strong>附加字段type来确认当前记录的对象</strong>属于什么<strong>类型</strong>&mdash;&mdash;ActiveRecord约定。</p>

<p>顾名思义，单表就是一张表，那么怎么呈现多种表的形态呢。当其他表引用它时，可以给予其他名字，但是要声明它实际是那张表(belongs_to :manager, :class_name => &ldquo;Person&rdquo;)，举例：</p>

<p>person.rb:</p>

<pre><code>Class Person &lt; ActiveRecord::Base
        belongs_to XXX
end
</code></pre>

<p>manager.rb:(继承Person类)</p>

<pre><code>Class Manager &lt; Person
end
</code></pre>

<p>rails console:</p>

<pre><code>XXX.first.manager
</code></pre>

<p>mysql:</p>

<pre><code>select people.* from people where people.type in ("Manager") and people.id=1
</code></pre>

<hr />

<h4>多态关联：</h4>

<p>通过建立虚拟表，通过虚拟表（先通过<strong>类型找到关联表</strong>，再通过<strong>外键找到对应的记录</strong>）访问。</p>

<p><strong>举例：</strong></p>

<p>假设我們已经有了Article与Photo这两个Model，然后我们希望这两个Model都可以被留言。不用多态关联的话，你得分別建立ArticleComment和PhotoComment的model。或者一个comment中要有两个外键：article_id和photo_id，虽然用多态也是两个字段，但当表多了就可以看出多态的好处。</p>

<p>现有个场景，有两个model：person和album，需要添加一个图片来做为其头像/封面。添加一个image model，按照以往需要对这几个model做以下关联设置：</p>

<p>没用多态关联前：不复杂，但是麻烦，如果<strong>以后加个book model之类</strong>的，也需要有个图做封面的，那又要<strong>改image model里的关联和migration</strong>了，一点都不DRY。</p>

<pre><code>class Person &lt; ActiveRecord::Base
  has_one :image, :dependent =&gt; :destroy
end

  class Album &lt; ActiveRecord::Base
         has_one :image, :dependent =&gt; :destroy
  end

  class Image &lt; ActiveRecord::Base
     belongs_to :person
         belongs_to :album
end
</code></pre>

<p>相应的image的migration要添加上关联字段：</p>

<pre><code>t.column :person_id, :integer, :null =&gt; false, :default =&gt; 0
    t.column :album_id, :integer, :null =&gt; false, :default =&gt; 0
</code></pre>

<p>使用多态关联后：</p>

<pre><code>    class Person &lt; ActiveRecord::Base
        has_one :image, :as =&gt; :iconable, :dependent =&gt; :destroy
    end
    class Album &lt; ActiveRecord::Base
        has_one :image, :as =&gt; :iconable, :dependent =&gt; :destroy
    end
    class Image &lt; ActiveRecord::Base
        belongs_to :iconable, :polymorphic =&gt; true
    end
</code></pre>

<p>Person和Album有了<strong>共同的一个虚拟的名字</strong>叫做iconable,image表就可以直接用外键iconable_id关联它,</p>

<p><strong>使用方法：</strong></p>

<p>添加：</p>

<pre><code>    @person = Person.new(params[:person])
    @person.build_image(params[:image])
    @person.save
</code></pre>

<p>读取：</p>

<pre><code>    @person.image
</code></pre>

<p>image 的属主：</p>

<pre><code>    @person.iconable
</code></pre>

<hr />

<h4>自引用：</h4>

<p>自引用就是<strong>一条记录可能引用同一张表的另一条记录</strong>：公司员工都有主管，主管也是员工。使用:class_name 和foregin_key加上has_many/has_one和belongs_to.</p>

<pre><code>class Employee &lt; ActiveRecord::Base
    belongs_to :manager,
      :class_name =&gt; "Employee",
      :foregin_key =&gt; "manager_id"
    belongs_to :mentor,
        :class_name =&gt; "Employee",
        :foregin_key =&gt; "mentor_id"
    has_many ：mentored_employees,
      :class_name =&gt; "Employee",
      :foreign_key =&gt; "mentor_id"
    has_many ：managed_employees,
      :class_name =&gt; "Employee",
      :foreign_key =&gt; "manager_id"
end
</code></pre>
]]></content>
  </entry>
  
</feed>
