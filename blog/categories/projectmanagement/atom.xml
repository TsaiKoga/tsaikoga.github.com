<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ProjectManagement | TsaiKoga Blog]]></title>
  <link href="https://TsaiKoga.github.com/blog/categories/projectmanagement/atom.xml" rel="self"/>
  <link href="https://TsaiKoga.github.com/"/>
  <updated>2019-02-15T09:17:33+08:00</updated>
  <id>https://TsaiKoga.github.com/</id>
  <author>
    <name><![CDATA[TsaiKoga]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[录单APP项目中的问题]]></title>
    <link href="https://TsaiKoga.github.com/blog/2018/10/28/lu-dan-appxiang-mu-zhong-de-wen-ti/"/>
    <updated>2018-10-28T15:46:00+08:00</updated>
    <id>https://TsaiKoga.github.com/blog/2018/10/28/lu-dan-appxiang-mu-zhong-de-wen-ti</id>
    <content type="html"><![CDATA[<h2>目录</h2>

<h4><a href="#1">分页重复数据问题</a></h4>

<h4><a href="#2">防止订单重复问题</a></h4>

<h4><a href="#3">订单号唯一问题</a></h4>

<h4><a href="#4">Web端报表系统使用导致APP端使用卡顿</a></h4>

<br/>


<br/>




<h2 id="1">分页重复数据问题</h2>


<hr />

<h4>背景：</h4>

<p>先解释一下，我们 app 项目中有一个录入订单模块，在这里每个店铺的工作人员会因为客户下单，在当天不停的进行录单；</p>

<p>这些订单按照当天的顺序形成一个单号，例如1，2，3，4&hellip; &hellip; 就这样；</p>

<p>app 中还有一个功能，就是插单，也就是如果有一张单据昨天忘记录入，那么可以添加插单时间到昨天，那么这张订单就插入了昨天；</p>

<p>但是，录单的工作人员有几个人，也就是同时有人会刷新这个页面，看到订单列表；</p>

<p>因为 app 是下拉刷新，加载第二页数据，并且是按照单据倒叙排列的，最先出现的是最新的单据；</p>

<p>这时候员工A如果开单到 25 号单据，然后再开第26的时候，员工B想要刷新第二页（按照每10张一页），那么本来应该看到的是15号单开始的第二页，</p>

<p>由于员工A完成26号单，这时候刷出来的是16号单开始的第二页，也就是25,24,23,&hellip;,16,16,15,14,&hellip;中间重单了；</p>

<br/>


<h4>解决方法：</h4>

<p>为了防止这种现象，必须在后台增加一个 <strong>过滤条件</strong>；</p>

<p>因为由时间排序，那么只要拿创建时间 <code>created_at</code> 与 前端传来查询时间 <code>search_at</code> 进行比较就可以筛选出第二页；</p>

<p>由于还有插单，所以插单的时间绝对不能覆盖创建时间 <code>created_at</code>，要有一个插单时间 <code>inserted_at</code>，这样排序用 <code>inserted_at</code> 来排序即可；</p>

<br/>


<br/>




<h2 id='2'>防止订单重复问题</h2>


<hr />

<h4>背景：</h4>

<p>由于这是一个给批发市场店铺的 app ；所以批发市场的店铺人员有限，但每天的订单数量又比较多，</p>

<p>这时候员工录入订单往往快速而又烦躁，对订单开单后可能会不停点击提交；虽然 IOS 端和 Android 端以对点击按钮做了屏蔽；</p>

<p>但是还是无法百分百杜绝一个单重复性提交；</p>

<p>这时候需要前端和后端配合一起防止同一张订单重复问题；</p>

<br/>


<h4>解决方法：</h4>

<p>前端给订单生成一个唯一码，一般用时间戳+随机数生成，这里我们用单词 exist_flag 代替；</p>

<p>然后前端发出请求，带上这个参数到后端；</p>

<p>后端接收到请求后首先将其用 redis 进行检验判断是否重复；</p>

<p>```php
if (Redis::get(&lsquo;orders:&rsquo;. $user_id . &lsquo;&ndash;&rsquo; . $exist_flag)) {</p>

<pre><code>return $this-&gt;fail(self::ERROR_CODE, "你还有订单正在进行中，请勿重复提交");
</code></pre>

<p>} else {</p>

<pre><code>Redis::set('orders:'. $user_id . '-' . $exist_flag, 1, 180);
</code></pre>

<p>}
```</p>

<br/>


<br/>




<h2 id='3'>订单号唯一问题</h2>


<hr />

<h4>背景：</h4>

<p>正如前面所提到的，订单按照每日生成唯一的订单号1,2,3,4,5 &hellip;&hellip;；</p>

<p>这是针对当天唯一的号码，并且当天不能重复，并且生成单据最好能较快，不要因为顺序问题影响体验；</p>

<br/>


<h4>解决方法：</h4>

<p>利用联合唯一索引来解决；</p>

<p>例如单号字段为 <code>transaction_daily_serial</code>, 时间为 <code>inserted_at</code></p>

<p>这里使用插单是插入选择日期的最后单据，因为这样不会导致重新更改其他单号；</p>

<p>那么联合唯一索引：</p>

<p><code>sql
alter table transaction add unique index daily_sel_ins_at(transaction_daily_serial, inserted_at);
</code></p>

<br/>


<br/>




<h2 id='4'>Web端报表系统使用导致APP端使用卡顿</h2>


<hr />

<h4>背景：</h4>

<p>APP 作为一个有点类似 ERP 的在线客户端，客户需要一些导出的Excel报表数据，包括（出入库数据，货品数据，订单总览）等等内容；</p>

<p>但由于数据内容非常庞大，并且客户不想要分批下载，他要一张excel展示所有时间段的数据；一开始数据量不多的时候，系统也没有为他们加时间限制；</p>

<p>后期，数据库数据量已经达到10G以上的时候，一段时间在业务高峰期出现 app 使用卡顿现象；</p>

<p>通过查询后台日志，我发现在这些卡顿时间都出现报表导出接口；</p>

<p>并且 APP 和 web 报表系统 是放在同一台服务器上；</p>

<br/>


<h4>解决方法：</h4>

<p>预想方案是有以下几个：</p>

<ol>
<li><p>分库【主从数据库】：因为 web 报表系统是查询数据，导出数据的系统，所以是只读系统，而 APP 是可读可写的；
分库可以保证 web 报表操作不影响 APP 手机端；</p></li>
<li><p>数据归档：将旧数据进行归档存储；</p></li>
<li><p>解决慢查询SQL</p></li>
<li><p>限制导出数据大小</p></li>
</ol>


<br/>


<p>由于公司项目较多，经费有限，无法再提供多一台服务器来专门用作 web 报表系统，所以方案一被取消；</p>

<p>数据归档虽然 CTO 答应采纳，但是当务之急是先解决目前问题，所以先从 方案三 和 方案四 下手；</p>

<p>方案三：通过阿里云的慢查询日志，定位到 SQL 语句，从而定位代码段；大部分慢查询可以通过添加联合索引解决；
但是一部分 smelly 的 SQL ORM 旧代码，就得重新编写优化；</p>

<p>方案四：根据客户需求和对应一个月的单据数量，给出最多只能下载一个月的数据；</p>

<br/>


<br/>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[公司项目中 Git 的使用方法]]></title>
    <link href="https://TsaiKoga.github.com/blog/2016/08/06/gong-si-xiang-mu-zhong-git-de-shi-yong-fang-fa/"/>
    <updated>2016-08-06T16:10:00+08:00</updated>
    <id>https://TsaiKoga.github.com/blog/2016/08/06/gong-si-xiang-mu-zhong-git-de-shi-yong-fang-fa</id>
    <content type="html"><![CDATA[<p>Git 是开源的分布式版本控制器，用于敏捷高效地处理任何或小或大的项目。</p>

<p>它被应用到很多 Rails 开发项目中。 公司对于 Git 也有适合的一套用法。</p>

<h4>背景</h4>

<hr />

<p>首先我来介绍一下公司的大致情况，然后阐述一下公司如何用Git进行工作：</p>

<p>我们公司是一家外企电商平台，产品在国外销售，技术部在中国，所以会有时差。面对这类问题，我们技术部这边对项目进行开发完善，
确定每周二的一个时间点为项目上线时间（因为这个时间点用户量极少），所有大改动和新功能都会在本周的这个时间点上线，我们称之为【常规上线】。
对于项目突然出现的 Bug ，或是上线后出现的 Bug，我们也会更改然后上线，这次上线属于当天的紧急上线，我们称之为【紧急上线】，取名为Hot Fix。</p>

<p>OK，接着来看看我们是如何使用 Git 进行如上的上线操作的。</p>

<h3>操作流程</h3>

<hr />

<h4>分支介绍</h4>

<p>先来看看我们项目主要的分支吧：</p>

<ul>
<li><p>master 主分支，用来部署周二的常规上线。</p></li>
<li><p>release 发布分支，这个分支的代码一定是生产环境下的分支（代码最新），用于切除 Hotfix 分支，作紧急上线处理。</p></li>
<li><p>testing 常规上线的测试分支，这里的代码用于测试，周二常规上线后可以删除后重建；不与master相同，测试完此分支与master分支无关；
用于当测试出现 BUG，修复很多次，最后测试通过；本地可以将最后通过的commits都合并为一个commit提交到master，保证commit的整洁，减少冲突。</p></li>
</ul>


<h4>常规上线</h4>

<p>接着，我们来看看如何常规上线，假设这周我有一个任务要完成，从 master 切出一个分支叫做 develop
``` sh</p>

<pre><code>git checkout -b develop
git commit -m "First Commit"
git push origin develop
</code></pre>

<p>```</p>

<p>然后周二正式上线，我们周一先将自己的分支本地测完，然后“合并”到公共的 testing 分支【记住是merge哦，不是rebase】；
``` sh</p>

<pre><code>git checkout testing                # from develop to testing
# git merge develop                 # 这里一般是发到 github 上给别人 pr，或是发到gitlab上给别人 mr
git push origin testing             # 如果是通过 gitlab/github mr/pr 后，这里将是 git pull origin testing
BRANCH=testing cap staging deploy   # 这里的 BRANCH 是通过 .bashrc 设置环境变量，deploy/staging.rb 中 set :branch, ENV["BRANCH"] || "master"
</code></pre>

<p>```</p>

<h4>注意事项 （merge 和 rebase）</h4>

<blockquote><p>有个问题需要注意，曾经我将我的代码rebase到testing上；</p>

<pre><code>git checkout testing
git rebase develop
</code></pre>

<p>rebase 会将 testing 和 develop 两个分支中的commit整理成 testing 一个分支，但是当两个分支中有一个commit发生冲突的时候
<img src="/images/posts/2016-08-06/git-rebase.png" title="rebase的图示" alt="git rebase" /></p>

<p>这个冲突如上图，来自于 develop 的 commit，你将它 rebase 到了 testing 上，正当你觉得一切顺利的时候；</p>

<p>你想要 push 你的代码到远程的 testing，你会发现需要 pull 代码，然而当你 pull 代码后，你又发现原来的冲突，然后解决冲突，然后再 pull 代码，这样无限循环下去&hellip;</p>

<p>这是因为远程的 testing 就是没解决冲突前的 testing 分支，你 rebase 后解决冲突的 commit 是 develop 的commit，这样你再次拉代码下来，冲突又再次出现了。</p></blockquote>

<p>所以，使用“merge”！这里 merge 后，develop 的 commit3 会与 testing 产生冲突，解决完冲突后，merge 不像 rebase 会把解决完的放在原来的 commit3 上，而是你需要
新提交一个解决冲突后的 commit【我们叫它commit4】，这样就 pull 的代码遇到 commit4，发现已被解决，就没有冲突了。</p>

<h4>紧急上线 Hotfix</h4>

<p>看到上面的常规上线，我们结束了周二的工作任务；周三来了，你来到办公室，发现昨天上线的内容还需要修改，并且必须在今天上线。这时候我们需要如下分支：</p>

<ul>
<li><p>release 分支， 周二从 master 分支部署到正式服务器后，将 master 代码 merge release 分支，release上的代码即代表着线上的最新代码。</p></li>
<li><p>hotfix160803 分支，从名字可以看出 hotfix + 日期，这个是从 release 切出来的，像testing分支一样，让所有要紧急发布的程序员将今天自己的分支合到这里进行测试。</p></li>
</ul>


<p>具体操作就是
1. 首先我们从 release 下载线上的代码 <code>git pull origin release:release</code>
2. release 分支切出一个 hotfix 分支 <code>git checkout -b hotfix160803</code>
3. 提交 hotfix160803 到远程，让大家可以合并代码
4. 建立自己的紧急开发分支 <code>git checkout -b hotfix-dev</code></p>

<p>如果已经有人提交了hotfix160803，则只需要 pull 下来，然后建立自己的分支开发。</p>

<p>接下来改完代码后的操作其实和常规上线一样。
``` sh</p>

<pre><code>git push hotfix-dev
</code></pre>

<p>```</p>

<p>gitlab 或 github 上 mr 或 pr
``` sh</p>

<pre><code>git checkout hotfix160803
git pull hotfix160803 # 将合并后的代码拉下来
BRANCH=hotfix160803 cap staging deploy
</code></pre>

<p>```</p>

<p>测试完毕后，将 hotfix160803 merge 到 release，发布release。</p>

<p>忙碌的一天就结束了。</p>

<h4>关于 Capistrano 的代码</h4>

<p>你的代码放在 gitlab 上面，项目运行在某个服务器A上，你将代码提交到 gitlab 上，然后 cap deploy；
其实cap deploy 是通过 clone 你的 gitlab 上的代码到服务器A上的</p>

<p>关于抽出逻辑，制作一个功能，其他传入简单参数，
关于方法里面，只有if，那干脆将if放方法外面；
关于需求，通过每个条件都列出来检查。
对于更改数据，记住留份log作为备份，将数据记录下来，以便回滚。</p>

<h4>经常使用的 Git 命令</h4>

<p>``` sh</p>

<pre><code>git checkout -b testing         # 新建分支testing 并切换到上面

git commit -m "Koga"            # commit
git commit --amend              # 将 add 的新修改也提交到之前的commit，并且可以更改commit名称

git pull origin master:master   # 拉远程的master到本地master，如果本地没有，则新建并拉代码下来，并且所在的分支也会拉master的内容下来，可以将其add 后checkout掉
git push origin master          # 提交到远程master分支，如果git push -f origin master，将强制提交

git rebase master               # 将当前分支与master合成一条
git reset HEAD~1                # 重置 上一个 commit，但是修改内容还是保留，只是还没commit
git merge master                # 将master合并到当前分支

git branch                      # 显示所有分支
git branch -D testing           # 删除 testing 分支
git branch -m dev               # 更改分支名称

git stash                       # 将更改内容暂存
git stash pop                   # 将暂存内容弹出
git stash clear                 # 清除暂存内容
</code></pre>

<p>```</p>

<p>让 bash 显示当前Git的分支及当前路径（如果有python的virtualenv，也显示在开头）：</p>

<p>``` sh</p>

<h6>#</h6>

<h1>shell obtain the git&rsquo;s current branch name</h1>

<h6>#</h6>

<p>find_git_branch() {
  local dir=. head
  until [ &ldquo;$dir&rdquo; -ef / ]; do</p>

<pre><code>if [ -f "$dir/.git/HEAD" ]; then
  head=$(&lt; "$dir/.git/HEAD")
  if [[ $head = ref:\ refs/heads/* ]]; then
    git_branch="[${head#*/*/}]"
  elif [[ $head != '' ]]; then
    git_branch="[no branch]"
  else
    git_branch="[unknow]"
  fi
  return
fi
dir="../$dir"
</code></pre>

<p>  done
  git_branch=&lsquo;&rsquo;
}
PROMPT_COMMAND=&ldquo;find_git_branch; $PROMPT_COMMAND&rdquo;
export PS1=&ldquo;(<code>basename \"$VIRTUAL_ENV\"</code>)\u@\h:\w\$git_branch\$ &rdquo;
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷开发]]></title>
    <link href="https://TsaiKoga.github.com/blog/2014/02/25/min-jie-kai-fa/"/>
    <updated>2014-02-25T13:23:00+08:00</updated>
    <id>https://TsaiKoga.github.com/blog/2014/02/25/min-jie-kai-fa</id>
    <content type="html"><![CDATA[<p><img src="/images/posts/2014-02-25/minjie.jpg" title="敏捷开发图" alt="图片无法显示" /></p>

<h5>敏捷开发的定义：</h5>

<p>是一种<strong>以人为核心、迭代、循环渐进的开发方法</strong>。在敏捷开发中项目被切分为多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。简而言之，就是把一个大项目切分成多个<strong>相互联系但可独立运行的子项目</strong>，并<strong>分别完成</strong>。在此过程软件一直处于可使用状态。</p>

<h5>敏捷开发 5 大价值观</h5>

<ol>
<li>沟通: 团队内部的开发人员之间沟通。</li>
<li>简单: 就是指简单的建模，如画一两张图表来代替几十甚至几百行的代码。</li>
<li>反馈: 过度自信是编程的职业病，反馈则是其处方。</li>
<li>勇气: 当你的决策证明是不合适的时候，你就需要做出重大的决策，放弃或重构你的工作，修正你的方向。</li>
<li>谦逊: 这个就不用我解释了。</li>
</ol>


<h5>敏捷开发核心做法</h5>

<ol>
<li>测试驱动开发</li>
<li>结对编程: 指<strong>两位程序员</strong>肩并肩地坐在同一台电脑前<strong>合作完成</strong>同一个设计、同一个算法、同一段代码或同一组测试。</li>
<li>持续集成:</li>
<li>每日站立会议</li>
<li>共同拥有代码</li>
<li>系统隐喻</li>
</ol>


<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了敏捷开发模式，目前所具有的开发模式还有好几种,如：瀑布模型，快速原型模型，增量模型，螺旋模型，喷泉模型。
 我在大学的实验室中使用 Rails 框架进行开发，使用的是敏捷开发模式。虽然如此，但是我们团队的敏捷开发还是带有其他模型的特征，可能因为我们还是学生团队，不是一个真正意义上的商业团队(我们平常还必须上课)。</p>

<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我先通过我们团队负责的一个项目（在这里我们叫它为ce）来阐述，我们为什么不是真正的敏捷，而是有有快速原型和增量的特征的敏捷，或者说我们是采用混合模式。</p>

<p><span style="text-align:center"><img src="/images/posts/2014-02-25/zengliang.jpg" title="增量模型图" alt="图片无法显示" /></span></p>

<ol>
<li><p>ce 首先通过实现前台大部分界面（没有功能）的<strong>样品给客户观看并给予讲解</strong>。客户可以清楚的看到有具体形态而无功能的样品，从而有助于客户提出有<strong>针对性的修改意见</strong>。而参与调研的师兄们对<strong>样品进行再次修改</strong>，并再次呈现给客户看，直到双方达成共识为止；之后师兄们就对这些调研后的资料进行讨论并据此形成<strong>规格说明文档</strong>（我们的规格说明文档是前台界面的图片，并用文字等方式对其功能进行阐述，当然还有一些流程图），然后把之前做的不具有功能的<strong>样品抛弃</strong>。很明显这是<strong>结合了快速原型模型</strong>，从而得到它的<strong>优点</strong>：规格说明文档<strong>正确的描述客户的需求</strong>，减少了设计和编码阶段发生的可能性错误。</p></li>
<li><p>当进入开发阶段时，团队要求将这个 ce 项目分成三期；每期有几条流程，而各个阶段的流程互不影响。并在第一期开发结束后部署给企业使用，这样企业就能拥有<strong>充裕的时间学习和适应</strong>此系统,减少一个新系统可能给客户组织带来的冲击。第二期进行开发直至完成后再部署给企业，这样企业已经事先使用过系统，对系统的排斥性不会那么强了。<strong>增量模型是将软件产品作为一系列的增量构件来设计，编码，集成和测试</strong>。而 ce 的这种开发方式明显和增量模型类似,当然，也可以说是<strong>敏捷开发的增量交付</strong>。</p></li>
<li><p>最后，我想要通过实验室的 ce 项目来说明敏捷开发的特征。</p></li>
</ol>


<p><strong>持续集成：</strong>一开始，我已经提到 ce 调研，那时候形成的规格说明文档有项目每个页面的设计方式，这样 ce 的每个模块以及每个页面都已经划分好，剩下的就是开发人员对每个页面的实现。实现一个页面后进行白盒测试，一个模块的所有页面完成时进行集成测试，这符合敏捷开发的方式。</p>

<p><strong>测试驱动开发：</strong>很可惜，团队的成员（包括老成员）没有 <strong>TDD (测试驱动开发)</strong> 的经验，我们使用一个星期的时间学习，最后在讨论中决定不使用 TDD，主要原因是 TDD 讲究先写测试后开发，而我们已经进入了开发阶段；再加上没有经验，如果使用TDD很大可能会拖慢项目进度。</p>

<p><strong>每日站立会议：</strong>我们每天都会在实验室进行工作，并且在每天晚上进行一个名叫<strong>三分钟站立会议</strong>的谈论，这个会议是就是要求每个人用三分钟左右的时间回报当天的工作内容、任务目标及所遇到的问题；我们希望从这次会议<strong>获得团队中每个人的任务进度和状态，从而有效的对进度进行把控</strong>。这就符合敏捷开发的五大价值观的其中两个：<strong>沟通</strong>和<strong>反馈</strong>。</p>

<p>我清楚的记得我当初被任命开发一个叫做“生产通知单”的页面，这个页面设计上不合理，集结了很多表，关系复杂，数据量大，并且由于 Extjs 特性，导致页面加载速度慢。后来团队选择废除这个页面，上千行的代码就这样被废除了。这也符合敏捷开发的一大价值观：<strong>勇气</strong>。</p>

<p><strong>系统拥有共同的代码：</strong>我们使用 Git 对 ce 的代码进行版本管理，由于 Git 巧妙的设计，团队<strong>每个成员都用有 ce 的代码</strong>（可能是各自不同的版本），不会因为仓库的代码错误和丢失而导致项目失败。</p>

<p><strong>代码的评审和重构：</strong>由于进入第一期末尾时，发现有很多 bug ，最终讨论设立一个代码评审人员(一个师兄，他的经验比我们丰富)，他负责对代码进行评审，并将需要重构的代码标记出来形成一个新的任务，将任务授予相应的开发人员。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目代码实现]]></title>
    <link href="https://TsaiKoga.github.com/blog/2013/11/06/xiang-mu-dai-ma-shi-xian/"/>
    <updated>2013-11-06T13:14:00+08:00</updated>
    <id>https://TsaiKoga.github.com/blog/2013/11/06/xiang-mu-dai-ma-shi-xian</id>
    <content type="html"><![CDATA[<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转眼间已经到了大四，想想大三和暑假在做的项目，自己在其中参与开发也曾参与管理；提到开发，从一开始对语言和业务都很陌生，任务不能按时完成；到后来逐渐掌握方法，准时完成任务。这个期间是一个逐渐迷失，然后发现问题，之后解决问题的过程。所以，在这里总结一下自己的经验和体会。</p>

<p>在讲述之前先说一下背景:</p>

<h4>背景：</h4>

<blockquote><p>首先，说一下我们所使用的语言和框架：</p>

<ul>
<li>前台：主要是Extjs</li>
<li>后台：Ruby</li>
<li>框架：Rails</li>
</ul>


<p>其次，说明一下我们所做的系统内容和功能：</p>

<ul>
<li>它是一个有关服装的一套生产流程的管理系统，包括板房打板，制作订单和制单，库存管理，采购管理，员工工资预算等内容。</li>
<li>页面所涉及的组件一般为panel（面板），form（表单），grid（表格），tree（树）和window（窗口）。</li>
<li>页面功能一般为对记录进行增删查改，对单据进行打印和导出Excel的功能。</li>
</ul>


<p>最后，讲述以下我们所做的系统复杂性：</p>

<ul>
<li>其实，由前面的内容和功能看好像不复杂，大部分系统都是这样。但是，看似简单的功能，实现并不容易；因为公司涉及流程范围广，系统较大，而系统所需的表有100多张；经常一个页面涉及10多张表，所以查找关联时比较吃力。</li>
</ul>
</blockquote>

<hr />

<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我开始接触此项目时，团队已经调研完并且设计好了数据库；而我们对数据库和业务都不熟悉；一开始就进入实现阶段常常会产生一个接连一个的问题；面对这些问题，我们探寻一条解决道路，团队开始采取的方法是：</p>

<p>1.业务完全不了解：</p>

<ul>
<li>先<strong>查看</strong>之前调研出来的<strong>流程图</strong>;</li>
<li>要求之前调研的人员对<strong>大体的流程</strong>进行<strong>讲解</strong>（因为流程图这种文档不一定能被第三方所理解，所以必须进行讲解；但是一开始讲解太全不易接受，所以我提议一开始讲大体内容，实现前针对模块的流程进行讲解）;</li>
<li>开发时对所做的<strong>模块流程</strong>进行<strong>讲解</strong>;</li>
</ul>


<p>2.数据库设计问题：</p>

<ul>
<li>对于这个问题，要看问题的大小，组织当时<strong>数据库设计相关人员进行讨论</strong>;</li>
<li>如果易于修改，不会改动太大，不会造成较大影响的，可以进行修改。</li>
<li>若影响较大，寻求其他途径代替，而不改动数据库。</li>
</ul>


<hr />

<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好，现在来讲我的代码实现方法，因为还是学生，不是什么正规公司，在代码设计上不像大公司那样规范；为了完成每一个任务，自己逐渐掌握的一套方法：</p>

<h4>准备:</h4>

<p>1.了解所要做的<strong>线路的流程</strong>，究竟是要干什么：
 理解所要实现的功能，所做的页面比起原来公司方式多了什么好处或修复了什么弊端。这样有助于理解并且找出系统设计的错误，及早改正。</p>

<p>2.查看<strong>数据库</strong>的设计的<strong>有关联的表</strong>：</p>

<ul>
<li>首先可以先看名字，你之后设计的函数或变量名字其实很多可以从数据库的表名或字段名借鉴。</li>
<li>将你前台所需要的字段找出来，你的页面将通过哪张表开始显示这个字段，找出一条搜索路径。（这里是一些大致需要查找的地方，如表单，表格）</li>
</ul>


<p>3.简要<strong>设计函数和分割代码</strong>(这里不是很细致地设计，而只是提出设计，实现是可以按着这个方向编写代码)：</p>

<ul>
<li>根据功能设计前台函数名（这也只能从较高层次上设计，如果熟练了，就知道页面大概要什么函数了，到那时设计起来简单）。</li>
<li>计高内聚低耦合的代码（这个比较难，一开始会因为站在比较高的地方，对一些细致的内容不了解或是业务知识不清晰而做出设计，最后由于一些功能不一致而修改，发现内聚性较差）。</li>
</ul>


<p>4.根据前台功能开始着手<strong>设计后台</strong>，前台所需发的请求，归纳后台需要什么内容，将后台处理过程划分，设计后台方法名。</p>

<h4>实现:</h4>

<p>5.开始着手敲代码实现，在前台这个期间我经历了三个阶段：</p>

<ul>
<li><p>没显示内容：怎么办？只好不停的调试；因为使用js的ext库做前台，所以我会在代码中用console.log()通过chrome的审查元素进行调试。</p>

<p><strong>结论：</strong>第一次还是不要一次性写太多内容；对于前台，你只需要写出那么一个总体显示框架就行了（如：一个布局：上面有个form，下面有个grid，显示出来就行了），之后再逐步细化。</p></li>
<li><p>当前台显示出来后，我认为根据MVC，View要发送请求，必须通过前台的功能实现，所以着手写之前所设计的前台功能代码：增删查改的ajax。但是，这样编代码后思想会很乱，容易分心，效率低下。</p>

<p><strong>结论：</strong>先做号前台页面的显示和最基本的数据显示（包括后台代码）；然后还是前台的一个功能设计出来后，后台根据这个请求实现，完成后台代码后测试这个功能是否可用。</p></li>
<li><p>最后一阶段就是一个一个的功能实现了，接在在一起时出现了问题，这时也只能调试。</p>

<p><strong>结论：</strong>调试时先判断是前台还是后台，这一期间一般发生在后台；如果可以通过提示的错误判断，则判断哪个范围出错，并那个范围进行调试；不然就顺着请求的访问路径测试，逐步调试。</p></li>
</ul>


<h4>总结:</h4>

<blockquote><p>编代码时</p>

<p>1.先整体后局部：做前台先将整体框架显示，再一个一个进行实现，而功能先不做；</p>

<p>2.先简单后复杂（复杂局部实现）：找出前台要显示的基本信息，编写后台实现基本的显示信息，再用一个功能一个功能实现;</p>

<p>3.先局部后整体：在此期间的不断地测试。</p></blockquote>
]]></content>
  </entry>
  
</feed>
